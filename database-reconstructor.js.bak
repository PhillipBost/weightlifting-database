/**
 * DATABASE RECONSTRUCTOR - STEP 5 (FINAL)
 * 
 * Purpose: Executes the database cleanup based on match assignments
 * Creates new lifter_id records for athletes needing them
 * Updates meet_results to point to correct lifter_id values
 * 
 * INPUT:
 *   - /output/match_assignments.json (from Step 4)
 *   - /output/orphan_results.json (from Step 4)
 * 
 * OUTPUT:
 *   - Database changes (new lifter records, updated meet results)
 *   - /output/reconstruction_report.json (complete audit trail)
 *   - Manual confirmation prompts before execution
 */

require('dotenv').config();
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { createClient } = require('@supabase/supabase-js');

// Initialize Supabase client
const supabase = createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_SECRET_KEY
);

// Configuration
const MATCH_FILE = './output/match_assignments.json';
const ORPHAN_FILE = './output/orphan_results.json';
const OUTPUT_DIR = './output';
const LOGS_DIR = './logs';
const REPORT_FILE = path.join(OUTPUT_DIR, 'reconstruction_report.json');
const LOG_FILE = path.join(LOGS_DIR, 'database-reconstructor.log');
const SCRIPT_VERSION = '1.0.0';

// Execution modes
const EXECUTION_MODE = {
    DRY_RUN: 'DRY_RUN',           // Show what would happen without making changes
    INTERACTIVE: 'INTERACTIVE',    // Ask for confirmation before each major change
    AUTOMATIC: 'AUTOMATIC'         // Execute all changes (dangerous!)
};

// Set the mode here
const CURRENT_MODE = EXECUTION_MODE.INTERACTIVE;

// Ensure directories exist
function ensureDirectories() {
    if (!fs.existsSync(OUTPUT_DIR)) {
        fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }
    if (!fs.existsSync(LOGS_DIR)) {
        fs.mkdirSync(LOGS_DIR, { recursive: true });
    }
}

// Logging utility
function log(message) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}\n`;
    
    // Console output
    console.log(message);
    
    // File output
    fs.appendFileSync(LOG_FILE, logMessage);
}

// Load match assignments
function loadMatchAssignments() {
    log('Loading match assignments...');
    
    if (!fs.existsSync(MATCH_FILE)) {
        throw new Error(`Match assignments file not found: ${MATCH_FILE}`);
    }
    
    const content = fs.readFileSync(MATCH_FILE, 'utf8');
    const data = JSON.parse(content);
    
    log(`Loaded ${data.data.length} match assignments`);
    return data.data;
}

// Load orphan results
function loadOrphanResults() {
    log('Loading orphan results...');
    
    if (!fs.existsSync(ORPHAN_FILE)) {
        log('No orphan results file found - assuming all results were matched');
        return [];
    }
    
    const content = fs.readFileSync(ORPHAN_FILE, 'utf8');
    const data = JSON.parse(content);
    
    log(`Loaded ${data.data.length} orphan results`);
    return data.data;
}

// Group matches by internal_id to determine new lifter creation needs
function analyzeLifterCreationNeeds(matches) {
    const athleteMap = new Map();
    
    for (const match of matches) {
        const internalId = match.matched_to.internal_id;
        
        if (!athleteMap.has(internalId)) {
            athleteMap.set(internalId, {
                internal_id: internalId,
                membership_number: match.matched_to.membership_number,
                birth_year: match.matched_to.birth_year,
                needs_new_lifter_id: match.matched_to.needs_new_lifter_id,
                contaminated_lifter_id: match.matched_to.contaminated_lifter_id,
                athlete_name: match.athlete_name,
                result_ids: [],
                meet_count: 0
            });
        }
        
        const athlete = athleteMap.get(internalId);
        athlete.result_ids.push(match.result_id);
        athlete.meet_count++;
    }
    
    return athleteMap;
}

// Create cleanup plan
function createCleanupPlan(matches, orphans) {
    log('\nAnalyzing cleanup requirements...');
    
    const athleteMap = analyzeLifterCreationNeeds(matches);
    
    const plan = {
        new_lifters_to_create: [],
        existing_lifters_to_update: [],
        meet_results_to_update: [],
        orphan_results: orphans
    };
    
    // Separate athletes needing new lifter_ids from those keeping existing ones
    for (const [internalId, athlete] of athleteMap) {
        if (athlete.needs_new_lifter_id) {
            plan.new_lifters_to_create.push({
                internal_id: athlete.internal_id,
                athlete_name: athlete.athlete_name,
                membership_number: athlete.membership_number,
                birth_year: athlete.birth_year,
                old_lifter_id: athlete.contaminated_lifter_id,
                result_ids: athlete.result_ids,
                meet_count: athlete.meet_count
            });
        } else {
            plan.existing_lifters_to_update.push({
                internal_id: athlete.internal_id,
                lifter_id: athlete.contaminated_lifter_id,
                athlete_name: athlete.athlete_name,
                membership_number: athlete.membership_number,
                result_ids: athlete.result_ids,
                meet_count: athlete.meet_count
            });
        }
    }
    
    // Create meet result update list
    for (const match of matches) {
        plan.meet_results_to_update.push({
            result_id: match.result_id,
            current_lifter_id: match.current_lifter_id,
            new_lifter_id: match.matched_to.needs_new_lifter_id ? 
                `NEW_${match.matched_to.internal_id}` : // Placeholder until created
                match.matched_to.contaminated_lifter_id,
            internal_id: match.matched_to.internal_id,
            athlete_name: match.athlete_name,
            meet_name: match.meet_name,
            date: match.date
        });
    }
    
    return plan;
}

// Display cleanup plan for review
function displayCleanupPlan(plan) {
    console.log('\n' + '='.repeat(60));
    console.log('üìã DATABASE RECONSTRUCTION PLAN');
    console.log('='.repeat(60));
    
    console.log('\n1Ô∏è‚É£ NEW LIFTER RECORDS TO CREATE:');
    console.log(`   Total: ${plan.new_lifters_to_create.length} new lifter records\n`);
    
    for (const lifter of plan.new_lifters_to_create) {
        console.log(`   ‚Ä¢ ${lifter.athlete_name} (ID: ${lifter.internal_id})`);
        console.log(`     - Membership: ${lifter.membership_number}`);
        console.log(`     - Birth Year: ${lifter.birth_year}`);
        console.log(`     - Will reassign ${lifter.meet_count} meet results`);
        console.log();
    }
    
    console.log('\n2Ô∏è‚É£ EXISTING LIFTERS TO UPDATE:');
    console.log(`   Total: ${plan.existing_lifters_to_update.length} lifters keeping current ID\n`);
    
    for (const lifter of plan.existing_lifters_to_update) {
        console.log(`   ‚Ä¢ ${lifter.athlete_name} (ID: ${lifter.internal_id})`);
        console.log(`     - Keeping lifter_id: ${lifter.lifter_id}`);
        console.log(`     - Has ${lifter.meet_count} correctly assigned results`);
        console.log();
    }
    
    console.log('\n3Ô∏è‚É£ MEET RESULTS TO UPDATE:');
    console.log(`   Total: ${plan.meet_results_to_update.length} results to reassign\n`);
    
    // Group by athlete for display
    const resultsByAthlete = {};
    for (const result of plan.meet_results_to_update) {
        if (!resultsByAthlete[result.athlete_name]) {
            resultsByAthlete[result.athlete_name] = [];
        }
        resultsByAthlete[result.athlete_name].push(result);
    }
    
    for (const [name, results] of Object.entries(resultsByAthlete)) {
        console.log(`   ${name}: ${results.length} results`);
    }
    
    if (plan.orphan_results.length > 0) {
        console.log('\n‚ö†Ô∏è ORPHAN RESULTS (need manual review):');
        console.log(`   Total: ${plan.orphan_results.length} unmatched results\n`);
        
        for (const orphan of plan.orphan_results) {
            console.log(`   ‚Ä¢ ${orphan.athlete_name} - ${orphan.meet_name} (${orphan.date})`);
            console.log(`     Reason: ${orphan.reason}`);
        }
    }
    
    console.log('\n' + '='.repeat(60));
}

// Get user confirmation
async function getUserConfirmation(message) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    
    return new Promise((resolve) => {
        rl.question(`\n${message} (yes/no): `, (answer) => {
            rl.close();
            resolve(answer.toLowerCase() === 'yes' || answer.toLowerCase() === 'y');
        });
    });
}

// Create new lifter record
async function createNewLifterRecord(lifterData, scrapedProfiles) {
    // Find the scraped profile data for this internal_id
    const profile = scrapedProfiles.find(p => p.internal_id === lifterData.internal_id);
    
    const newLifterData = {
        athlete_name: lifterData.athlete_name,
        internal_id: lifterData.internal_id,
        membership_number: parseInt(lifterData.membership_number),
        birth_year: lifterData.birth_year
    };
    
    // Add additional fields if available from scraped profile
    if (profile) {
        if (profile.profile_data.gender) newLifterData.gender = profile.profile_data.gender;
        if (profile.profile_data.club_name && profile.profile_data.club_name !== '-') {
            newLifterData.club_name = profile.profile_data.club_name;
        }
        if (profile.profile_data.wso) newLifterData.wso = profile.profile_data.wso;
        if (profile.profile_data.national_rank) {
            newLifterData.national_rank = parseInt(profile.profile_data.national_rank);
        }
    }
    
    // Check if lifter with this internal_id already exists
	const { data: existingLifter, error: findError } = await supabase
		.from('lifters')
		.select('lifter_id, athlete_name')
		.eq('internal_id', lifterData.internal_id)
		.single();

	if (findError && findError.code !== 'PGRST116') {
		throw new Error(`Failed to check for existing lifter: ${findError.message}`);
	}

	if (existingLifter) {
		log(`   ‚Üª Lifter already exists for internal_id ${lifterData.internal_id}: ${existingLifter.athlete_name} (lifter_id: ${existingLifter.lifter_id})`);
		return existingLifter.lifter_id;
	}

	// Create new lifter only if none exists
	const { data, error } = await supabase
		.from('lifters')
		.insert(newLifterData)
		.select('lifter_id')
		.single();

	if (error) {
		throw new Error(`Failed to create lifter: ${error.message}`);
	}

	return data.lifter_id;
}

// Update meet result with new lifter_id
async function updateMeetResult(resultId, newLifterId) {
    const { error } = await supabase
        .from('meet_results')
        .update({ lifter_id: newLifterId })
        .eq('result_id', resultId);
    
    if (error) {
        throw new Error(`Failed to update result ${resultId}: ${error.message}`);
    }
}

// Execute the cleanup plan
async function executeCleanupPlan(plan) {
    const executionReport = {
        mode: CURRENT_MODE,
        started_at: new Date().toISOString(),
        new_lifters_created: [],
        meet_results_updated: [],
        errors: []
    };
    
    try {
        // Step 1: Create new lifter records
        if (plan.new_lifters_to_create.length > 0) {
            log('\nüìù Creating new lifter records...');
            
            // Load scraped profiles for additional data
            const scrapedProfiles = loadScrapedProfilesForUpdate();
            
            for (const lifterToCreate of plan.new_lifters_to_create) {
                try {
                    if (CURRENT_MODE === EXECUTION_MODE.DRY_RUN) {
                        log(`   [DRY RUN] Would create lifter: ${lifterToCreate.athlete_name}`);
                        lifterToCreate.new_lifter_id = 'DRY_RUN_ID';
                    } else {
                        const newLifterId = await createNewLifterRecord(lifterToCreate, scrapedProfiles);
                        lifterToCreate.new_lifter_id = newLifterId;
                        log(`   ‚úÖ Created lifter_id ${newLifterId} for ${lifterToCreate.athlete_name} (internal_id: ${lifterToCreate.internal_id})`);
                        
                        executionReport.new_lifters_created.push({
                            internal_id: lifterToCreate.internal_id,
                            new_lifter_id: newLifterId,
                            athlete_name: lifterToCreate.athlete_name
                        });
                    }
                } catch (error) {
                    log(`   ‚ùå Failed to create lifter for ${lifterToCreate.athlete_name}: ${error.message}`);
                    executionReport.errors.push({
                        operation: 'CREATE_LIFTER',
                        internal_id: lifterToCreate.internal_id,
                        error: error.message
                    });
                }
            }
        }
        
        // Step 2: Update meet results
        if (plan.meet_results_to_update.length > 0) {
            log('\nüîÑ Updating meet results...');
            
            let updateCount = 0;
            for (const result of plan.meet_results_to_update) {
				try {
					// Determine the actual new lifter_id
					let newLifterId = result.new_lifter_id;
					
					// Handle the case where new_lifter_id is a number instead of string
					if (typeof result.new_lifter_id === 'number') {
						newLifterId = result.new_lifter_id;
						// Skip the string processing for numeric lifter_ids
					} else if (result.new_lifter_id && typeof result.new_lifter_id === 'string' && result.new_lifter_id.startsWith('NEW_')) {
						// Find the newly created lifter_id
						const internalId = parseInt(result.new_lifter_id.replace('NEW_', ''));
						const newLifter = plan.new_lifters_to_create.find(l => l.internal_id === internalId);
						newLifterId = newLifter?.new_lifter_id;
						
						if (!newLifterId) {
							throw new Error(`Could not find new lifter_id for internal_id ${internalId}`);
						}
					} else if (result.matched_to?.needs_new_lifter_id) {
						// Handle missing new_lifter_id - create the expected format
						const internalId = result.matched_to.internal_id;
						const newLifter = plan.new_lifters_to_create.find(l => l.internal_id === internalId);
						newLifterId = newLifter?.new_lifter_id;
					} else {
						// Use existing lifter_id
						newLifterId = result.current_lifter_id;
					}
					
					if (CURRENT_MODE === EXECUTION_MODE.DRY_RUN) {
						log(`   [DRY RUN] Would update result ${result.result_id}: lifter_id ${result.current_lifter_id} ‚Üí ${newLifterId}`);
					} else {
						await updateMeetResult(result.result_id, newLifterId);
						updateCount++;
						
						if (updateCount % 10 === 0) {
							log(`   ... updated ${updateCount}/${plan.meet_results_to_update.length} results`);
						}
						
						executionReport.meet_results_updated.push({
							result_id: result.result_id,
							old_lifter_id: result.current_lifter_id,
							new_lifter_id: newLifterId
						});
					}
				} catch (error) {
					log(`   ‚ùå Failed to update result ${result.result_id}: ${error.message}`);
					executionReport.errors.push({
						operation: 'UPDATE_RESULT',
						result_id: result.result_id,
						error: error.message
					});
				}
			}
            
            if (CURRENT_MODE !== EXECUTION_MODE.DRY_RUN) {
                log(`   ‚úÖ Updated ${updateCount} meet results`);
            }
        }
        
    } catch (error) {
        log(`\n‚ùå Critical error during execution: ${error.message}`);
        executionReport.errors.push({
            operation: 'CRITICAL',
            error: error.message
        });
    }
    
    executionReport.completed_at = new Date().toISOString();
    return executionReport;
}

// Load scraped profiles for additional lifter data
function loadScrapedProfilesForUpdate() {
    const scrapedDir = './output/successful_scrapes';
    const profiles = [];
    
    if (fs.existsSync(scrapedDir)) {
        const files = fs.readdirSync(scrapedDir).filter(f => f.endsWith('.json'));
        
        for (const file of files) {
            const content = fs.readFileSync(path.join(scrapedDir, file), 'utf8');
            const data = JSON.parse(content);
            if (data.data && Array.isArray(data.data)) {
                profiles.push(...data.data);
            }
        }
    }
    
    return profiles;
}

// Save execution report
function saveExecutionReport(report, plan) {
    const fullReport = {
        metadata: {
            timestamp: new Date().toISOString(),
            script_name: 'database-reconstructor',
            script_version: SCRIPT_VERSION,
            execution_mode: CURRENT_MODE
        },
        plan_summary: {
            new_lifters_planned: plan.new_lifters_to_create.length,
            meet_results_planned: plan.meet_results_to_update.length,
            orphan_results: plan.orphan_results.length
        },
        execution_results: report
    };
    
    fs.writeFileSync(REPORT_FILE, JSON.stringify(fullReport, null, 2));
    log(`\nüìÑ Execution report saved to: ${REPORT_FILE}`);
}

// Main execution function
async function main() {
    const startTime = Date.now();
    
    try {
        // Setup
        ensureDirectories();
        log('üöÄ Starting database reconstruction process');
        log(`üìã Execution mode: ${CURRENT_MODE}`);
        log('=' .repeat(60));
        
        // Load data
        const matches = loadMatchAssignments();
        const orphans = loadOrphanResults();
        
        // Create cleanup plan
        const plan = createCleanupPlan(matches, orphans);
        
        // Display plan
        displayCleanupPlan(plan);
        
        // Get confirmation if in interactive mode
        if (CURRENT_MODE === EXECUTION_MODE.INTERACTIVE) {
            const proceed = await getUserConfirmation(
                '‚ö†Ô∏è This will modify the database. Do you want to proceed?'
            );
            
            if (!proceed) {
                log('\n‚ùå Operation cancelled by user');
                process.exit(0);
            }
        } else if (CURRENT_MODE === EXECUTION_MODE.DRY_RUN) {
            log('\nüîç Running in DRY RUN mode - no changes will be made');
        }
        
        // Execute the plan
        const executionReport = await executeCleanupPlan(plan);
        
        // Save report
        saveExecutionReport(executionReport, plan);
        
        // Final summary
        const processingTime = Date.now() - startTime;
        log('\n' + '='.repeat(60));
        log('‚úÖ DATABASE RECONSTRUCTION COMPLETE');
        log(`   New lifters created: ${executionReport.new_lifters_created.length}`);
        log(`   Meet results updated: ${executionReport.meet_results_updated.length}`);
        log(`   Errors encountered: ${executionReport.errors.length}`);
        log(`   Processing time: ${processingTime}ms`);
        
        if (plan.orphan_results.length > 0) {
            log(`\n‚ö†Ô∏è Remember to manually review ${plan.orphan_results.length} orphan results`);
        }
        
        return executionReport;
        
    } catch (error) {
        log(`\n‚ùå Process failed: ${error.message}`);
        log(`üîç Stack trace: ${error.stack}`);
        process.exit(1);
    }
}

// Export for use by master script
module.exports = { main, createCleanupPlan };

// Run if called directly
if (require.main === module) {
    main();
}