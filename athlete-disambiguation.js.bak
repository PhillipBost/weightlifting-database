require('dotenv').config();

const puppeteer = require('puppeteer');
const fs = require('fs');
const { createClient } = require('@supabase/supabase-js');

// Initialize Supabase client
const supabase = createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_SECRET_KEY
);

class AthleteDisambiguationSystem {
    constructor() {
        // Fix: Load the division_codes object from your actual file structure
        const divisionData = JSON.parse(fs.readFileSync('division_base64_codes.json', 'utf8'));
        this.divisionCodes = divisionData.division_codes;
        this.browser = null;
        this.page = null;
        this.membershipCache = new Map(); // Cache to avoid re-scraping same URLs
    }

    async init() {
        this.browser = await puppeteer.launch({
            headless: true,
            args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        this.page = await this.browser.newPage();
        await this.page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
    }

    // Step 1: Get contaminated athletes from database
    async getContaminatedAthletes() {
		let allAthletes = [];
		let from = 0;
		const pageSize = 1000;
		
		while (true) {
			console.log(`Fetching athletes ${from + 1} to ${from + pageSize}...`);
			
			const { data: athletes, error } = await supabase
				.from('lifters')
				.select('athlete_name, internal_id, internal_id_2, internal_id_3, internal_id_4, internal_id_5')
				.or('internal_id_2.not.is.null,internal_id_3.not.is.null,internal_id_4.not.is.null,internal_id_5.not.is.null')
				.range(from, from + pageSize - 1);

			if (error) throw new Error(`Database error: ${error.message}`);
			
			allAthletes.push(...athletes);
			console.log(`  Retrieved ${athletes.length} athletes`);
			
			if (athletes.length < pageSize) break; // No more records
			from += pageSize;
		}
		
		console.log(`Found ${allAthletes.length} contaminated athletes to process`);
		return allAthletes;
	}

    // Step 2: Get all competitions for a contaminated athlete
    async getAthleteCompetitions(athleteName) {
		
		const { data: competitions, error } = await supabase
			.from('meet_results')
			.select(`
				meet_id,
				date,
				age_category,
				weight_class,
				lifter_name,
				lifter_id
			`)
			.eq('lifter_name', athleteName)
			.not('date', 'is', null)
			.not('age_category', 'is', null);

		if (error) throw new Error(`Error getting competitions for ${athleteName}: ${error.message}`);
		
		console.log(`  Found ${competitions.length} competitions for ${athleteName}`);
		return competitions;
	}

    // Step 3: Build Sport80 URL for a specific competition
    buildSport80URL(ageCategory, weightClass, competitionDate) {
        // Try exact matches first, then systematic alternatives
        const divisionVariants = [
            `${ageCategory} ${weightClass}`,                    // Exact as stored
            `(Inactive) ${ageCategory} ${weightClass}`,         // Try inactive version
            ageCategory,                                        // Just age category
            weightClass,                                        // Just weight class
        ];
        
        console.log(`    Looking for division: ${ageCategory} + ${weightClass}`);
        
        for (const variant of divisionVariants) {
            if (this.divisionCodes[variant]) {
                console.log(`    Found exact match: "${variant}" -> ${this.divisionCodes[variant]}`);
                return this.buildSport80URLWithCode(this.divisionCodes[variant], competitionDate);
            }
        }
        
        // Log some available divisions for debugging
        const availableDivisions = Object.keys(this.divisionCodes)
            .filter(div => div.includes(ageCategory) || div.includes(weightClass))
            .slice(0, 3);
        
        console.log(`    No match found. Similar available: ${availableDivisions.join(', ')}`);
        throw new Error(`No division code found for: "${ageCategory} ${weightClass}"`);
    }
    
    buildSport80URLWithCode(weightClassCode, competitionDate) {
        const filters = {
            date_range_start: competitionDate,
            date_range_end: competitionDate,
            weight_class: weightClassCode
        };

        const encodedFilters = btoa(JSON.stringify(filters));
        return `https://usaweightlifting.sport80.com/public/rankings/all?filters=${encodedFilters}`;
    }
	
	async scrapeInternalIdCompetitions(internalId) {
        const memberUrl = `https://usaweightlifting.sport80.com/public/rankings/member/${internalId}`;
        
        try {
            await this.page.goto(memberUrl, { waitUntil: 'networkidle0', timeout: 30000 });
            await new Promise(resolve => setTimeout(resolve, 2000));

            const competitions = await this.page.evaluate(() => {
                const results = [];
                const rows = document.querySelectorAll('tr, .competition-row');
                
                for (const row of rows) {
                    const text = row.textContent;
                    // Extract competition date, age category, weight class from row
                    // This will depend on Sport80's member page structure
                    // Return array of competition objects with date, age_category, weight_class
                }
                
                return results;
            });

            console.log(`    Found ${competitions.length} competitions for internal_id ${internalId}`);
            return competitions;

        } catch (error) {
            console.error(`    Error scraping member page ${memberUrl}: ${error.message}`);
            return [];
        }
    }

    // Step 4: Scrape membership numbers from Sport80 URL
    async scrapeMembershipNumbers(url, targetAthleteName) {
        // Check cache first
        const cacheKey = `${url}_${targetAthleteName}`;
        if (this.membershipCache.has(cacheKey)) {
            return this.membershipCache.get(cacheKey);
        }

        try {
            await this.page.goto(url, { waitUntil: 'networkidle0', timeout: 30000 });
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Extract membership numbers for athletes with matching names
            const membershipData = await this.page.evaluate((athleteName) => {
                const results = [];
                
                // Look for table rows or list items containing athlete data
                const rows = document.querySelectorAll('tr, .athlete-row, .result-row');
                
                for (const row of rows) {
                    const text = row.textContent;
                    
                    // If this row contains the athlete name we're looking for
                    if (text.toLowerCase().includes(athleteName.toLowerCase())) {
                        // Look for membership number patterns (usually numbers)
                        const membershipMatch = text.match(/\b\d{4,8}\b/g);
                        if (membershipMatch) {
                            results.push({
                                athleteName: athleteName,
                                membershipNumber: membershipMatch[0],
                                fullText: text.trim()
                            });
                        }
                    }
                }
                
                return results;
            }, targetAthleteName);

            // Cache the result
            this.membershipCache.set(cacheKey, membershipData);
            
            console.log(`    Found ${membershipData.length} membership matches for ${targetAthleteName}`);
            return membershipData;

        } catch (error) {
            console.error(`    Error scraping ${url}: ${error.message}`);
            return [];
        }
    }

    // Step 5: Process a single contaminated athlete
    async processContaminatedAthlete(athlete) {
		console.log(`\nProcessing contaminated athlete: ${athlete.athlete_name}`);
		
		const competitionMemberships = [];
		
		// Collect all internal IDs
		const internalIds = [
			athlete.internal_id,
			athlete.internal_id_2,
			athlete.internal_id_3,
			athlete.internal_id_4,
			athlete.internal_id_5,
			athlete.internal_id_6,
			athlete.internal_id_7,
			athlete.internal_id_8
		].filter(id => id !== null);
		

		const competitions = await this.getAthleteCompetitions(athlete.athlete_name);
		if (competitions.length === 0) {
			console.log(`  No competitions found for ${athlete.athlete_name}`);
			return null;
		}

		// Group competitions by internal_id AND membership number
		const competitionGroups = {};
		const unidentifiedCompetitions = [];

        // Process each competition
        for (const competition of competitions) {
            try {
                // Build Sport80 URL
                const url = this.buildSport80URL(competition.age_category, competition.weight_class, competition.date);
                
                console.log(`  Processing competition: ${competition.date} - ${competition.age_category} ${competition.weight_class}`);
                
                // Scrape membership numbers
                const membershipData = await this.scrapeMembershipNumbers(url, competition.lifter_name);
                
                // Associate membership numbers with this competition
                competitionMemberships.push({
                    ...competition,
                    membershipNumbers: membershipData,
                    sport80Url: url
                });

                // Rate limiting
                await new Promise(resolve => setTimeout(resolve, 1500));

            } catch (error) {
                console.error(`  Error processing competition ${competition.meet_id}: ${error.message}`);
                competitionMemberships.push({
                    ...competition,
                    membershipNumbers: [],
                    error: error.message
                });
            }
        }

        return {
            athleteName: athleteName,
            competitions: competitionMemberships,
            analysis: this.analyzeCompetitionMemberships(competitionMemberships)
        };
    }

    // Step 6: Analyze membership patterns to determine how to split
    analyzeCompetitionMemberships(competitions) {
        const membershipGroups = new Map();
        const unidentifiedCompetitions = [];

        competitions.forEach(competition => {
            if (competition.membershipNumbers && competition.membershipNumbers.length > 0) {
                // Take the first membership number found (could be enhanced to handle multiple)
                const membershipNumber = competition.membershipNumbers[0].membershipNumber;
                
                if (!membershipGroups.has(membershipNumber)) {
                    membershipGroups.set(membershipNumber, []);
                }
                membershipGroups.get(membershipNumber).push(competition);
            } else {
                unidentifiedCompetitions.push(competition);
            }
        });

        return {
            distinctAthletes: membershipGroups.size,
            membershipGroups: Object.fromEntries(membershipGroups),
            unidentifiedCompetitions: unidentifiedCompetitions,
            splitRequired: membershipGroups.size > 1
        };
    }

    // Step 7: Generate split recommendations
    generateSplitPlan(athleteData) {
        if (!athleteData.analysis.splitRequired) {
            return { action: 'NO_SPLIT_NEEDED', reason: 'Only one distinct athlete found' };
        }

        const splits = [];
        let splitIndex = 1;

        for (const [membershipNumber, competitions] of Object.entries(athleteData.analysis.membershipGroups)) {
            splits.push({
                newAthleteName: `${athleteData.athleteName} (Person ${splitIndex})`,
                membershipNumber: membershipNumber,
                competitionCount: competitions.length,
                competitions: competitions.map(c => c.meet_id)
            });
            splitIndex++;
        }

        return {
            action: 'SPLIT_REQUIRED',
            originalAthleteName: athleteData.athleteName,
            splits: splits,
            unidentifiedCompetitions: athleteData.analysis.unidentifiedCompetitions
        };
    }

    // Step 8: Save analysis results
    async saveAnalysis(athleteData, splitPlan) {
        const timestamp = new Date().toISOString();
        const filename = `athlete_analysis_${athleteData.athleteName.replace(/[^a-zA-Z0-9]/g, '_')}_${timestamp.split('T')[0]}.json`;
        
        const analysisData = {
            timestamp: timestamp,
            athleteName: athleteData.athleteName,
            totalCompetitions: athleteData.competitions.length,
            analysis: athleteData.analysis,
            splitPlan: splitPlan,
            rawData: athleteData
        };

        fs.writeFileSync(`analysis_output/${filename}`, JSON.stringify(analysisData, null, 2));
        console.log(`  Analysis saved to: ${filename}`);
        
        return analysisData;
    }

    // Main processing function
    async processAllContaminatedAthletes(limit = 10) {
        // Ensure output directory exists
        if (!fs.existsSync('analysis_output')) {
            fs.mkdirSync('analysis_output');
        }

        const athletes = await this.getContaminatedAthletes(limit);
        const results = [];

        for (const athlete of athletes) {
            try {
                const athleteData = await this.processContaminatedAthlete(athlete);
                if (athleteData) {
                    const splitPlan = this.generateSplitPlan(athleteData);
                    const analysis = await this.saveAnalysis(athleteData, splitPlan);
                    results.push(analysis);
                }
            } catch (error) {
                console.error(`Failed to process ${athlete.athlete_name}: ${error.message}`);
            }
        }

        // Generate summary report
        this.generateSummaryReport(results);
        return results;
    }

    // Generate summary report
    generateSummaryReport(results) {
        const summary = {
            totalProcessed: results.length,
            requiresSplit: results.filter(r => r.splitPlan.action === 'SPLIT_REQUIRED').length,
            noSplitNeeded: results.filter(r => r.splitPlan.action === 'NO_SPLIT_NEEDED').length,
            totalDistinctAthletes: results.reduce((sum, r) => sum + r.analysis.distinctAthletes, 0),
            splitDetails: results.filter(r => r.splitPlan.action === 'SPLIT_REQUIRED').map(r => ({
                athleteName: r.athleteName,
                distinctAthletes: r.analysis.distinctAthletes,
                totalCompetitions: r.totalCompetitions
            }))
        };

        fs.writeFileSync('analysis_output/summary_report.json', JSON.stringify(summary, null, 2));
        
        console.log('\n=== DISAMBIGUATION SUMMARY ===');
        console.log(`Total athletes processed: ${summary.totalProcessed}`);
        console.log(`Athletes requiring split: ${summary.requiresSplit}`);
        console.log(`Athletes with no split needed: ${summary.noSplitNeeded}`);
        console.log(`Total distinct real athletes found: ${summary.totalDistinctAthletes}`);
        console.log('Summary saved to: analysis_output/summary_report.json');
    }

    async close() {
        if (this.browser) {
            await this.browser.close();
        }
    }
}

// Usage example
async function main() {
    const disambiguator = new AthleteDisambiguationSystem();
    
    try {
        await disambiguator.init();
        
        // Process first 10 contaminated athletes
        await disambiguator.processAllContaminatedAthletes();
        
    } catch (error) {
        console.error('Disambiguation failed:', error);
    } finally {
        await disambiguator.close();
    }
}

// Export for use as module
module.exports = { AthleteDisambiguationSystem };

// Run if called directly
if (require.main === module) {
    main();
}