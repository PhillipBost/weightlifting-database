const puppeteer = require('puppeteer');
const fs = require('fs');

const JSON_FILE = 'internal_ids.json';
const CSV_FILE = 'internal_ids.csv';
const BATCH_SIZE = 50;
const REQUEST_DELAY = 500; // ms
const MAX_CONSECUTIVE_ERRORS = 10;
const MAX_RETRIES = 3;

// Enhanced data structure with permanent failures
function loadExistingData() {
  if (fs.existsSync(JSON_FILE)) {
    try {
      const data = JSON.parse(fs.readFileSync(JSON_FILE, 'utf8'));
      console.log(`Loaded existing data: ${Object.keys(data.athletes || {}).length} athletes`);
      console.log(`  - Failed IDs (retryable): ${data.failedIds?.length || 0}`);
      console.log(`  - Permanently failed IDs: ${data.permanentlyFailedIds?.length || 0}`);
      
      return {
        athletes: data.athletes || {},
        failedIds: data.failedIds || [],
        permanentlyFailedIds: data.permanentlyFailedIds || [],
		uploadConflicts: data.uploadConflicts || [],
        lastProcessedId: data.lastProcessedId || 0,
        processed: data.processed || {}
      };
    } catch (error) {
      console.log('Error reading JSON file, starting fresh:', error.message);
    }
  } else {
    console.log('JSON file does not exist. Starting fresh.');
  }
  
  return {
    athletes: {},
    failedIds: [],
    permanentlyFailedIds: [],
    lastProcessedId: 0,
    processed: {}
  };
}

// Save data with validation
function saveDataToJSON(data) {
  try {
    // Validate data structure
    if (!data.permanentlyFailedIds) data.permanentlyFailedIds = [];
    if (!data.processed) data.processed = {};
    
    // Remove duplicates between failed and permanently failed
    data.failedIds = data.failedIds.filter(id => !data.permanentlyFailedIds.includes(id));
    
    fs.writeFileSync(JSON_FILE, JSON.stringify(data, null, 2));
    return true;
  } catch (error) {
    console.error('Error saving JSON file:', error);
    return false;
  }
}

// Export to CSV (unchanged)
function exportToCSV(athletes) {
  try {
    const csv = require('csv-writer');
    const csvWriter = csv.createObjectCsvWriter({
      path: CSV_FILE,
      header: [
        { id: 'athleteId', title: 'internal_id' },
        { id: 'athleteName', title: 'lifter' }
      ]
    });

    const records = Object.entries(athletes).map(([id, name]) => ({
      athleteId: parseInt(id),
      athleteName: name
    })).sort((a, b) => a.athleteId - b.athleteId);

    csvWriter.writeRecords(records);
    console.log(`Exported ${records.length} athletes to CSV file.`);
    return true;
  } catch (error) {
    console.error('Error exporting to CSV:', error);
    return false;
  }
}

// Enhanced scraping with error type detection
async function scrapeAthleteData(page, id, retryCount = 0) {
  const url = `https://usaweightlifting.sport80.com/public/rankings/member/${id}`;
  
  try {
    const response = await page.goto(url, { waitUntil: 'networkidle0', timeout: 10000 });
    
    // Check for HTTP errors
    if (!response.ok()) {
      const status = response.status();
      console.log(`HTTP ${status} for ID ${id}`);
      
      // Mark certain HTTP errors as permanent
      if (status === 404 || status === 403 || status === 410) {
        return { error: 'permanent', message: `HTTP ${status}` };
      }
      
      return { error: 'retry', message: `HTTP ${status}` };
    }
    
    // Wait for table with shorter timeout
    await page.waitForSelector('table', { timeout: 2000 });
    
    const athleteName = await page.$$eval('table tr', (rows) => {
      if (rows.length > 1) {
        const cols = rows[1].querySelectorAll('td');
        if (cols.length > 3) {
          const lifterName = cols[3].textContent.trim();
          if (lifterName && lifterName !== '-' && lifterName.length > 0) {
            return lifterName;
          }
        }
      }
      return null;
    });

    if (athleteName) {
      return { success: true, data: athleteName };
    } else {
      // No data found - could be empty profile (permanent) or parsing issue (retry)
      return { error: 'permanent', message: 'No athlete data found' };
    }
    
  } catch (error) {
    // Network/timeout errors - retry
    if (retryCount < MAX_RETRIES) {
      console.log(`Retry ${retryCount + 1}/${MAX_RETRIES} for athlete ID ${id}: ${error.message}`);
      await new Promise(resolve => setTimeout(resolve, 1000));
      return scrapeAthleteData(page, id, retryCount + 1);
    } else {
      return { error: 'retry', message: `Failed after ${MAX_RETRIES} retries: ${error.message}` };
    }
  }
}

// Utility function to manually move IDs to permanent failures
function markAsPermanentlyFailed(data, ids, reason = 'Manual') {
  const newPermanentFailures = [];
  
  ids.forEach(id => {
    const numId = typeof id === 'string' ? parseInt(id) : id;
    
    // Remove from failedIds if present
    data.failedIds = data.failedIds.filter(fId => fId !== numId);
    
    // Add to permanently failed if not already there
    if (!data.permanentlyFailedIds.includes(numId)) {
      data.permanentlyFailedIds.push(numId);
      newPermanentFailures.push(numId);
    }
  });
  
  if (newPermanentFailures.length > 0) {
    console.log(`Marked ${newPermanentFailures.length} IDs as permanently failed: ${newPermanentFailures.join(', ')}`);
    console.log(`Reason: ${reason}`);
  }
}

(async () => {
  let browser;
  
  try {
    // Load existing data
    let data = loadExistingData();
    
    // Optional: Mark specific IDs as permanently failed before starting
    // Example: markAsPermanentlyFailed(data, [404, 500, 999], 'Known invalid IDs');
    
    browser = await puppeteer.launch({
        headless: "new",
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-gpu',
            '--no-first-run',
            '--disable-extensions'
        ],
        slowMo: 25
    });
    
    const page = await browser.newPage();
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');
    
    let totalProcessed = 0;
    let permanentFailuresThisSession = 0;
    
    // Phase 1: Retry previously failed IDs (excluding permanent failures)
    if (data.failedIds.length > 0) {
      console.log(`\n=== PHASE 1: Retrying ${data.failedIds.length} previously failed IDs ===`);
      
      const stillFailedIds = [];
      const newPermanentFailures = [];
      
      for (let i = 0; i < data.failedIds.length; i++) {
        const failedId = data.failedIds[i];
        
        // Skip if somehow this ID is now in permanent failures
        if (data.permanentlyFailedIds.includes(failedId)) {
          console.log(`↷ Skipping ID ${failedId} - already permanently failed`);
          continue;
        }
        
        console.log(`Retrying failed ID ${failedId} (${i + 1}/${data.failedIds.length})`);
        
        const result = await scrapeAthleteData(page, failedId);
        
        if (result.success) {
          data.athletes[failedId] = result.data;
          data.processed[failedId] = true;
          totalProcessed++;
          console.log(`✓ Successfully retried: ${result.data} (ID: ${failedId})`);
        } else if (result.error === 'permanent') {
          newPermanentFailures.push(failedId);
          permanentFailuresThisSession++;
          console.log(`✗ Permanent failure: ID ${failedId} - ${result.message}`);
        } else {
          stillFailedIds.push(failedId);
          console.log(`✗ Still failed after retry: ID ${failedId} - ${result.message}`);
        }
        
        // Save progress every 10 retries
        if ((i + 1) % 10 === 0) {
          data.failedIds = stillFailedIds.concat(data.failedIds.slice(i + 1));
          data.permanentlyFailedIds.push(...newPermanentFailures);
          saveDataToJSON(data);
          console.log(`Progress saved after ${i + 1} retries.`);
        }
        
        await new Promise(resolve => setTimeout(resolve, REQUEST_DELAY));
      }
      
      // Update arrays with final results
      data.failedIds = stillFailedIds;
      data.permanentlyFailedIds.push(...newPermanentFailures);
      
      console.log(`Phase 1 completed. ${totalProcessed} previously failed IDs recovered.`);
      console.log(`${newPermanentFailures.length} IDs marked as permanently failed.`);
    }
    
    // Phase 2: Continue sequential scraping
    console.log(`\n=== PHASE 2: Sequential scraping starting from ID ${data.lastProcessedId + 1} ===`);
    console.log(`Will skip ${data.permanentlyFailedIds.length} permanently failed IDs`);
    
    let id = data.lastProcessedId + 1;
    let consecutiveErrors = 0;
    
    while (consecutiveErrors < MAX_CONSECUTIVE_ERRORS) {
      console.log(`Processing athlete ID: ${id}`);
      
      // Skip if permanently failed
      if (data.permanentlyFailedIds.includes(id)) {
        console.log(`↷ Skipping ID ${id} - permanently failed`);
        id++;
        continue;
      }
      
      // Skip if we already have this athlete
      if (data.athletes[id]) {
        console.log(`↷ Skipping ID ${id} - already have: ${data.athletes[id]}`);
        id++;
        continue;
      }
      
      const result = await scrapeAthleteData(page, id);
      
      if (result.success) {
        data.athletes[id] = result.data;
		saveDataToJSON(data);
        data.processed[id] = true;
        data.lastProcessedId = id;
        consecutiveErrors = 0;
        totalProcessed++;
        console.log(`✓ Fetched: ${result.data} (ID: ${id})`);
      } else if (result.error === 'permanent') {
        data.permanentlyFailedIds.push(id);
		saveDataToJSON(data);
        data.lastProcessedId = id;
        permanentFailuresThisSession++;
        console.log(`✗ Permanent failure: ID ${id} - ${result.message}`);
        consecutiveErrors = 0; // Don't count permanent failures as consecutive errors
      } else {
        consecutiveErrors++;
        data.failedIds.push(id);
		saveDataToJSON(data);
        data.lastProcessedId = id;
        console.log(`✗ Temporary failure: ID ${id} - ${result.message} (${consecutiveErrors}/${MAX_CONSECUTIVE_ERRORS} consecutive errors)`);
      }
      
      id++;
      
      if (consecutiveErrors < MAX_CONSECUTIVE_ERRORS) {
        await new Promise(resolve => setTimeout(resolve, REQUEST_DELAY));
      }
    }
    
    // Final save
    const success = saveDataToJSON(data);
    if (success) {
      exportToCSV(data.athletes);
    }
    
    console.log(`\n=== SCRAPING COMPLETED ===`);
    console.log(`Total athletes in database: ${Object.keys(data.athletes).length}`);
    console.log(`Athletes processed this session: ${totalProcessed}`);
    console.log(`Failed IDs to retry next time: ${data.failedIds.length}`);
    console.log(`Permanently failed IDs: ${data.permanentlyFailedIds.length}`);
    console.log(`New permanent failures this session: ${permanentFailuresThisSession}`);
    console.log(`Last processed ID: ${data.lastProcessedId}`);
    console.log(`Reason for stopping: ${consecutiveErrors >= MAX_CONSECUTIVE_ERRORS ? 'Too many consecutive errors' : 'Manual stop'}`);
    
    if (data.failedIds.length > 0) {
      console.log(`Failed IDs: ${data.failedIds.slice(0, 20).join(', ')}${data.failedIds.length > 20 ? '...' : ''}`);
    }
    
    if (data.permanentlyFailedIds.length > 0 && permanentFailuresThisSession > 0) {
      const recentPermanentFailures = data.permanentlyFailedIds.slice(-Math.min(20, permanentFailuresThisSession));
      console.log(`Recent permanent failures: ${recentPermanentFailures.join(', ')}`);
    }
    
  } catch (error) {
    console.error('Fatal error occurred:', error);
  } finally {
    if (browser) {
      await browser.close();
    }
  }
})();

// Export utility function for manual management
module.exports = { markAsPermanentlyFailed };