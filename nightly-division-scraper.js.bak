const puppeteer = require('puppeteer');
const fs = require('fs');
const path = require('path');

// =================================================================
// BATCH DIVISION SCRAPER - Processes specific range of divisions
// Scrapes only LAST MONTH + CURRENT MONTH data for efficiency
// =================================================================
const CONFIG = {
    OVERWRITE_EXISTING_FILES: false,
    DELAY_BETWEEN_ATHLETES: 100,    // Reduced from 2000ms
    DELAY_BETWEEN_DIVISIONS: 2000,  // Reduced from 3000ms since less data
    TARGET_YEAR: new Date().getFullYear(),
    HEADLESS: false,
    // Get division range from environment
    DIVISION_START: parseInt(process.env.DIVISION_START || '1'),
    DIVISION_END: parseInt(process.env.DIVISION_END || '35'),
    DAY_NAME: process.env.DAY_NAME || 'Unknown',
    // For testing - process fewer divisions
    TEST_MODE: process.env.TEST_MODE === 'true',
    TEST_LIMIT: 3,
    // Date range: last month + current month only
    MONTHS_TO_SCRAPE: 2
};

// Utility functions
function ensureDirectoryExists(dirPath) {
    if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
    }
}

function escapeCSV(value) {
    if (value === null || value === undefined) return '';
    const str = String(value);
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return '"' + str.replace(/"/g, '""') + '"';
    }
    return str;
}

function createExtractionIssuesLogger() {
    const issuesFilePath = './athlete_extraction_details.csv';
    
    if (!fs.existsSync(issuesFilePath)) {
        const headers = ['division_number', 'division_name', 'issue_type', 'athlete_name', 'membership_id', 'row_data', 'description', 'batch_day'];
        fs.writeFileSync(issuesFilePath, headers.join(',') + '\n');
    }
    
    return {
        logIssue: (divisionNumber, divisionName, issueType, athleteName, membershipId, rowData, description) => {
            const row = [
                divisionNumber,
                escapeCSV(divisionName),
                issueType,
                escapeCSV(athleteName || ''),
                escapeCSV(membershipId || ''),
                escapeCSV(JSON.stringify(rowData)),
                escapeCSV(description),
                CONFIG.DAY_NAME
            ];
            fs.appendFileSync(issuesFilePath, row.join(',') + '\n');
        }
    };
}

function loadDivisions() {
    // First, check if the activedivisions.csv file exists (from your uploaded file)
    const divisionsFile = './activedivisions.csv';
    const altDivisionsFile = './active divisions.csv';
    
    let fileToUse = null;
    if (fs.existsSync(divisionsFile)) {
        fileToUse = divisionsFile;
    } else if (fs.existsSync(altDivisionsFile)) {
        fileToUse = altDivisionsFile;
    } else {
        throw new Error('Division file not found! Looking for activedivisions.csv or "active divisions.csv"');
    }
    
    console.log(`üìã Loading divisions from: ${fileToUse}`);
    const content = fs.readFileSync(fileToUse, 'utf8');
    const lines = content.split('\n').map(line => line.trim()).filter(line => line);
    
    // Skip header if present
    const firstLine = lines[0];
    const isHeader = firstLine && (
        firstLine.toLowerCase().includes('division') ||
        firstLine.toLowerCase().includes('age') ||
        firstLine.toLowerCase().includes('weight')
    );
    
    const divisions = isHeader ? lines.slice(1) : lines;
    
    console.log(`üìã Loaded ${divisions.length} total divisions`);
    return divisions;
}

function getDivisionsForBatch(divisions) {
    // Adjust indices (environment uses 1-based, array is 0-based)
    const startIdx = CONFIG.DIVISION_START - 1;
    const endIdx = CONFIG.DIVISION_END;
    
    const batchDivisions = divisions.slice(startIdx, endIdx);
    
    console.log(`üìÖ ${CONFIG.DAY_NAME} Batch Configuration:`);
    console.log(`   Total divisions available: ${divisions.length}`);
    console.log(`   Requested range: ${CONFIG.DIVISION_START} to ${CONFIG.DIVISION_END}`);
    console.log(`   Actual divisions to process: ${batchDivisions.length}`);
    
    if (batchDivisions.length > 0) {
        console.log(`   First division: ${batchDivisions[0]}`);
        console.log(`   Last division: ${batchDivisions[batchDivisions.length - 1]}`);
    }
    
    if (CONFIG.TEST_MODE) {
        console.log(`‚ö†Ô∏è  TEST MODE: Limiting to ${CONFIG.TEST_LIMIT} divisions`);
        return batchDivisions.slice(0, CONFIG.TEST_LIMIT);
    }
    
    return batchDivisions;
}

function splitAgeCategoryAndWeightClass(combinedString) {
    if (!combinedString) return { ageCategory: '', weightClass: '' };
    
    const weightClassPattern = /(\+?\d+\+?\s*kg)$/i;
    const match = combinedString.match(weightClassPattern);
    
    if (match) {
        const weightClass = match[1].trim();
        const ageCategory = combinedString.replace(weightClassPattern, '').trim();
        return { ageCategory, weightClass };
    }
    
    return { ageCategory: combinedString, weightClass: '' };
}

function isAthleteAlreadyProcessed(membershipId) {
    if (!membershipId) return false;
    
    const athleteFile = path.join('./output/athletes', `athlete_${membershipId}.csv`);
    return fs.existsSync(athleteFile) && !CONFIG.OVERWRITE_EXISTING_FILES;
}

function createAthleteCSV(membershipId, profileData, sourceDivision) {
    const athletesDir = './output/athletes';
    ensureDirectoryExists(athletesDir);
    
    const athleteFile = path.join(athletesDir, `athlete_${membershipId}.csv`);
    const profile = profileData.profileData;
    
    const headers = [
        'membership_number', 'athlete_name', 'gender', 'club_name', 'wso',
        'national_rank', 'internal_id', 'lifter_age', 'competition_age',
        'lift_date', 'birth_year', 'Meet', 'Date', 'Age Category',
        'Weight Class', 'Lifter', 'Body Weight (Kg)', 'Snatch Lift 1',
        'Snatch Lift 2', 'Snatch Lift 3', 'C&J Lift 1', 'C&J Lift 2',
        'C&J Lift 3', 'Best Snatch', 'Best C&J', 'Total', 'qpoints',
        'qmasters', 'sinclair', 'sinclairmeltzerfaber',
        'sinclairhuebnermetzerfaber', 'batch_id', 'batch_date'
    ];
    
    const timestamp = new Date().toISOString();
    const batchId = `${CONFIG.DAY_NAME.toLowerCase()}_${membershipId}_${Date.now()}`;
    
    let csvContent = headers.join(',') + '\n';
    
    const { ageCategory, weightClass } = splitAgeCategoryAndWeightClass(sourceDivision);
    
    let birthYear = '';
    if (profile.lifterAge && profile.liftDate) {
        try {
            const age = parseInt(profile.lifterAge);
            const liftYear = new Date(profile.liftDate).getFullYear();
            if (!isNaN(age) && !isNaN(liftYear)) {
                birthYear = liftYear - age;
            }
        } catch (error) {}
    }
    
    const row = [
        escapeCSV(profile.membershipId),
        escapeCSV(profile.athleteName),
        escapeCSV(profile.gender),
        escapeCSV(profile.club),
        escapeCSV(profile.wso),
        escapeCSV(profile.nationalRank),
        escapeCSV(profile.internalId),
        escapeCSV(profile.lifterAge),
        '', // competition_age
        escapeCSV(profile.liftDate),
        escapeCSV(birthYear),
        '', '', // Meet, Date
        escapeCSV(ageCategory),
        escapeCSV(weightClass),
        escapeCSV(profile.athleteName),
        '', '', '', '', '', '', '', // Body weight and lifts
        '', '', // Best lifts
        escapeCSV(profile.total),
        '', '', '', '', '', // Points calculations
        escapeCSV(batchId),
        escapeCSV(timestamp)
    ];
    
    csvContent += row.join(',') + '\n';
    fs.writeFileSync(athleteFile, csvContent);
    
    return { filePath: athleteFile };
}

// Calendar navigation functions (from your original nightly-division-scraper.js)
async function handleComplexDatePicker(page, targetYear, interfaceSelector, targetMonth = 1, targetDay = 1) {
    console.log(`üóìÔ∏è Fast navigating calendar (${interfaceSelector}) to ${targetMonth}/${targetDay}/${targetYear}...`);

    const container = await page.$(interfaceSelector);
    if (!container) throw new Error(`Could not find calendar container: ${interfaceSelector}`);

    const monthMap = {
        January: 1, February: 2, March: 3, April: 4, May: 5, June: 6,
        July: 7, August: 8, September: 9, October: 10, November: 11, December: 12
    };

    async function getCurrentMonthYear() {
        const containerBox = await container.boundingBox();
        if (!containerBox) return null;

        const headers = await page.$$('.v-date-picker-header__value, .v-date-picker-header, [class*="date-picker"] [class*="header"]');
        let closestHeader = null;
        let minDistance = Infinity;

        for (const header of headers) {
            const isVisible = await header.evaluate(el => {
                return el.offsetParent !== null && getComputedStyle(el).visibility !== 'hidden';
            });
            if (!isVisible) continue;

            const headerBox = await header.boundingBox();
            if (!headerBox) continue;

            const verticalDistance = Math.abs(headerBox.y - containerBox.y);
            if (verticalDistance < minDistance && verticalDistance < 150) {
                minDistance = verticalDistance;
                closestHeader = header;
            }
        }

        if (closestHeader) {
            const text = (await (await closestHeader.getProperty('textContent')).jsonValue()).trim();
            const match = text.match(/^(January|February|March|April|May|June|July|August|September|October|November|December) \d{4}$/);
            if (match) {
                const [monthName, yearStr] = text.split(' ');
                return { monthName, year: parseInt(yearStr, 10), raw: text };
            }
        }
        return null;
    }

    async function getPrevMonthButton() {
        const containerBox = await container.boundingBox();
        if (!containerBox) throw new Error('Could not get bounding box of calendar container');

        const buttons = await page.$$('button[aria-label="Previous month"]');
        let closestBtn = null;
        let minDistance = Infinity;

        for (const btn of buttons) {
            const isVisible = await btn.evaluate(el => {
                return el.offsetParent !== null && getComputedStyle(el).visibility !== 'hidden';
            });
            if (!isVisible) continue;

            const btnBox = await btn.boundingBox();
            if (!btnBox) continue;

            const verticalDistance = Math.abs(btnBox.y - containerBox.y);
            if (verticalDistance < minDistance && verticalDistance < 150) {
                minDistance = verticalDistance;
                closestBtn = btn;
            }
        }

        if (!closestBtn) throw new Error('Could not find previous month button in the active calendar');
        return closestBtn;
    }
    
    async function getNextMonthButton() {
        const containerBox = await container.boundingBox();
        if (!containerBox) throw new Error('Could not get bounding box of calendar container');

        const buttons = await page.$$('button[aria-label="Next month"]');
        let closestBtn = null;
        let minDistance = Infinity;

        for (const btn of buttons) {
            const isVisible = await btn.evaluate(el => {
                return el.offsetParent !== null && getComputedStyle(el).visibility !== 'hidden';
            });
            if (!isVisible) continue;

            const btnBox = await btn.boundingBox();
            if (!btnBox) continue;

            const verticalDistance = Math.abs(btnBox.y - containerBox.y);
            if (verticalDistance < minDistance && verticalDistance < 150) {
                minDistance = verticalDistance;
                closestBtn = btn;
            }
        }

        if (!closestBtn) throw new Error('Could not find next month button in the active calendar');
        return closestBtn;
    }

    const currentMonthYear = await getCurrentMonthYear();
    if (!currentMonthYear) throw new Error('Could not determine current month/year in date picker');
    
    const currentMonth = monthMap[currentMonthYear.monthName];
    const currentYear = currentMonthYear.year;
    
    console.log(`üìÖ Starting from: ${currentMonthYear.raw}`);

    const totalMonthsDifference = (targetYear - currentYear) * 12 + (targetMonth - currentMonth);

    if (totalMonthsDifference === 0) {
        console.log('‚úÖ Already at target month/year');
    } else if (totalMonthsDifference > 0) {
        // Need to go forward
        console.log(`üöÄ Need to go forward ${totalMonthsDifference} months - executing rapid clicks...`);
        
        const nextButton = await getNextMonthButton();
        
        for (let i = 0; i < totalMonthsDifference; i++) {
            await nextButton.click();
            await page.waitForTimeout(25);
        }

        console.log(`‚úÖ Completed ${totalMonthsDifference} forward navigation clicks`);
    } else {
        // Need to go backward
        const totalMonthsToGoBack = Math.abs(totalMonthsDifference);
        console.log(`üöÄ Need to go back ${totalMonthsToGoBack} months - executing rapid clicks...`);
        
        const prevButton = await getPrevMonthButton();
        
        for (let i = 0; i < totalMonthsToGoBack; i++) {
            await prevButton.click();
            await page.waitForTimeout(25);
        }

        console.log(`‚úÖ Completed ${totalMonthsToGoBack} backward navigation clicks`);
    }

    // Verify we're at the correct month/year after navigation
    const finalMonthYear = await getCurrentMonthYear();
    if (finalMonthYear) {
        const finalMonth = monthMap[finalMonthYear.monthName];
        const finalYear = finalMonthYear.year;
        console.log(`üìÖ Final position: ${finalMonthYear.raw}`);
        
        if (finalMonth !== targetMonth || finalYear !== targetYear) {
            console.log(`‚ö†Ô∏è Navigation ended at wrong position. Expected: ${targetMonth}/${targetYear}, Got: ${finalMonth}/${finalYear}`);
        }
    }

    // Now click on the target day
    console.log(`üìÖ Selecting day ${targetDay}`);
    await page.waitForTimeout(200);

    const clickResult = await page.evaluate((day) => {
        const allButtons = document.querySelectorAll('button');
        const dayButtons = Array.from(allButtons).filter(btn => btn.textContent.trim() === day.toString());
        
        if (dayButtons.length > 0) {
            const buttonIndex = (dayButtons.length > 1) ? 1 : 0;
            const dayButton = dayButtons[buttonIndex];
            dayButton.click();
            return { success: true };
        }
        return { success: false };
    }, targetDay);

    if (clickResult.success) {
        console.log(`‚úÖ Clicked day ${targetDay}`);
        await page.waitForTimeout(25);
    } else {
        console.log(`‚ùå Could not find day ${targetDay} button`);
    }
    
    // After selecting the day, click the OK button inside the calendar container    
    const okButtons = await container.$$('button, .v-btn, .s80-btn');
    let okClicked = false;
    for (const btn of okButtons) {
        const text = (await (await btn.getProperty('textContent')).jsonValue()).trim().toLowerCase();
        if (['ok', 'apply', 'done', 'select'].includes(text)) {
            await btn.click();
            okClicked = true;
            console.log('‚úÖ Clicked OK/APPLY button in calendar');
            break;
        }
    }
    if (!okClicked) {
        console.log('‚ö†Ô∏è No OK/APPLY button found in calendar, calendar may close automatically');
    }

    console.log(`‚úÖ Fast date picker navigation completed for ${targetMonth}/${targetDay}/${targetYear}`);
}

async function handleDateField(page, fieldSelector, targetYear, fieldType, targetMonth = 1, targetDay = 1) {
    console.log(`üìÖ Handling ${fieldType} date field: ${fieldSelector}`);

    try {
        // Check if the field exists
        const fieldExists = await page.$(fieldSelector);
        if (!fieldExists) {
            console.log(`‚ö†Ô∏è ${fieldType} date field not found: ${fieldSelector}`);
            return;
        }
        
        // Click the date field to open its calendar
        await page.click(fieldSelector);
        await page.waitForTimeout(200);

        // Look for various date picker interfaces that might have opened
        const datePickerInterfaces = [
            '.v-date-picker',
            '.s80-date-picker',
            '.v-menu__content',
            '[role="dialog"]',
            '.v-dialog',
            'input[type="date"]'
        ];

        let activeInterface = null;
        for (const selector of datePickerInterfaces) {
            try {
                const element = await page.$(selector);
                if (element) {
                    const isVisible = await element.evaluate(el => {
                        return el.offsetParent !== null && getComputedStyle(el).visibility !== 'hidden';
                    });
                    if (isVisible) {
                        activeInterface = selector;
                        console.log(`‚úÖ Found active ${fieldType} date interface: ${selector}`);
                        break;
                    }
                }
            } catch (err) {
                // Continue checking other selectors
            }
        }

        if (!activeInterface) {
            console.log(`‚ö†Ô∏è No ${fieldType} date picker interface found`);
            await page.keyboard.press('Escape');
            await page.waitForTimeout(500);
            return;
        }

        if (activeInterface.includes('date-picker') || activeInterface.includes('v-menu')) {
            await handleComplexDatePicker(page, targetYear, activeInterface, targetMonth, targetDay);
            console.log(`üîö Waiting for ${fieldType} date calendar to close...`);
            await page.waitForTimeout(100);
        }

        console.log(`‚úÖ ${fieldType} date field handling completed`);

    } catch (error) {
        console.error(`‚ùå Failed to handle ${fieldType} date field:`, error.message);
        await page.keyboard.press('Escape');
        await page.waitForTimeout(500);
    }
}

// Main scraping function for a division
async function scrapeDivisionAthletes(page, division, divisionIndex, globalDivisionNumber, issuesLogger) {
    console.log(`\nüèãÔ∏è Scraping division #${globalDivisionNumber}: ${division}`);
    
    const { ageCategory, weightClass } = splitAgeCategoryAndWeightClass(division);
    
    try {
        // Navigate to rankings page for first division only
        if (divisionIndex === 0) {
            console.log('Navigating to rankings page...');
            await page.goto('https://usaweightlifting.sport80.com/public/rankings/all', {
                waitUntil: 'networkidle0',
                timeout: 30000
            });
            await page.waitForSelector('text=Select Filters', {timeout: 10000});
        } else {
            // Click Show Filters for subsequent divisions
            const filterButton = await page.$('button[aria-label="Show Filters"]');
            if (filterButton) {
                await filterButton.click();
                await page.waitForTimeout(1000);
            }
        }
        
        // Set weight class
        await page.click('#weight_class');
        await page.keyboard.down('Control');
        await page.keyboard.press('a');
        await page.keyboard.up('Control');
        
        await page.type('#weight_class', `${ageCategory} ${weightClass}`, {delay: 2});
        await page.waitForTimeout(500);
        await page.keyboard.press('ArrowDown');
        
        // Special navigation for certain weight classes (from your original code)
        if ((ageCategory.includes("Men's") && (weightClass === "81kg" || weightClass === "55kg" || weightClass === "69 kg")) ||
            (ageCategory.includes("Men's 13 Under Age Group") && (weightClass === "39kg" || weightClass === "40kg" || weightClass === "44kg" || weightClass === "48kg" || weightClass === "49kg" || weightClass === "55kg")) ||
            (ageCategory.includes("Men's 11 Under Age Group") && (weightClass === "40kg" || weightClass === "44kg" || weightClass === "48kg")) ||
            (ageCategory.includes("Men's 14-15 Age Group") && (weightClass === "48kg" || weightClass === "49kg" || weightClass === "55kg")) ||
            (ageCategory.includes("Men's 16-17 Age Group") && (weightClass === "49kg" || weightClass === "55kg" || weightClass === "69 kg" || weightClass === "81kg"))) {
            await page.keyboard.press('ArrowDown');
        }
        
        if ((ageCategory.includes("Men's 13 Under Age Group") && weightClass === "36kg") ||
            (ageCategory.includes("Men's 14-15 Age Group") && weightClass === "44kg")) {
            await page.keyboard.press('ArrowDown');
            await page.keyboard.press('ArrowDown');
        }
        
        await page.keyboard.press('Enter');
        
        // Set date range (last month + current month only)
        const today = new Date();
        const currentYear = today.getFullYear();
        const currentMonth = today.getMonth() + 1; // JavaScript months are 0-based, so add 1
        const currentDay = today.getDate();
        
        // Calculate last month
        let lastMonth = currentMonth - 1;
        let lastMonthYear = currentYear;
        if (lastMonth === 0) {
            lastMonth = 12;
            lastMonthYear = currentYear - 1;
        }
        
        // Start date: First day of last month
        const startYear = lastMonthYear;
        const startMonth = lastMonth;
        const startDay = 1;
        
        // End date: Today (or last day of current month)
        const endYear = currentYear;
        const endMonth = currentMonth;
        const endDay = new Date(currentYear, currentMonth, 0).getDate(); // Last day of current month
        
        console.log(`üìÖ Setting date range: ${startMonth}/${startDay}/${startYear} to ${endMonth}/${endDay}/${endYear}`);
        console.log(`   (Last month + Current month only)`);
        
        await handleDateField(page, '#form__date_range_start', startYear, 'start', startMonth, startDay);
        await page.waitForTimeout(100);
        
        await handleDateField(page, '#form__date_range_end', endYear, 'end', endMonth, endDay);
        await page.waitForTimeout(100);
        
        await page.click('body');
        await page.waitForTimeout(500);
        
        // Apply filters
        const applyButton = await page.evaluateHandle(() => {
            const buttons = Array.from(document.querySelectorAll('button'));
            return buttons.find(btn => btn.textContent?.includes('Apply'));
        });
        
        if (applyButton) {
            await applyButton.click();
            // Wait for results to load (reduced wait time since less data)
            await page.waitForTimeout(2000);
        }
        
        // Extract athletes from results
        let allAthletes = [];
        let hasMorePages = true;
        let currentPage = 1;
        
        while (hasMorePages) {
            const pageAthletes = await page.evaluate(() => {
                const rows = Array.from(document.querySelectorAll('.v-data-table__wrapper tbody tr'));
                return rows.map(row => {
                    const cells = Array.from(row.querySelectorAll('td'));
                    const cellTexts = cells.map(cell => cell.textContent?.trim() || '');
                    
                    if (cellTexts.length < 8) return null;
                    
                    return {
                        nationalRank: cellTexts[0],
                        athleteName: cellTexts[3],
                        total: cellTexts[2],
                        gender: cellTexts[4],
                        lifterAge: cellTexts[5],
                        club: cellTexts[6],
                        membershipId: cellTexts[7],
                        liftDate: cellTexts[9],
                        wso: cellTexts[12] || ''
                    };
                }).filter(a => a && a.membershipId);
            });
            
            allAthletes = allAthletes.concat(pageAthletes);
            console.log(`   Page ${currentPage}: Found ${pageAthletes.length} athletes (Total: ${allAthletes.length})`);
            
            // Check for next page
            const nextPageExists = await page.evaluate(() => {
                const nextBtn = document.querySelector('.v-data-footer__icons-after .v-btn:not([disabled])');
                if (nextBtn && !nextBtn.disabled) {
                    nextBtn.click();
                    return true;
                }
                return false;
            });
            
            if (nextPageExists) {
                await page.waitForTimeout(1500); // Reduced wait time
                currentPage++;
            } else {
                hasMorePages = false;
            }
        }
        
        // Remove duplicates
        const uniqueAthletes = allAthletes.filter((athlete, index, arr) => 
            arr.findIndex(a => a.membershipId === athlete.membershipId) === index
        );
        
        console.log(`   Total unique athletes: ${uniqueAthletes.length}`);
        
        return {
            success: true,
            athletes: uniqueAthletes,
            totalFound: uniqueAthletes.length
        };
        
    } catch (error) {
        console.error(`‚ùå Error scraping division: ${error.message}`);
        issuesLogger.logIssue(
            globalDivisionNumber,
            division,
            'DIVISION_SCRAPE_ERROR',
            '',
            '',
            {},
            error.message
        );
        return {
            success: false,
            athletes: [],
            totalFound: 0
        };
    }
}

// Upload function for batch - uses YOUR EXISTING athlete-csv-uploader.js
async function uploadBatchToSupabase() {
    const { spawn } = require('child_process');
    
    console.log('\nüì§ Uploading batch to Supabase using existing uploader...');
    
    // Check for YOUR existing uploader
    const uploaderPath = './athlete-csv-uploader.js';
    if (!fs.existsSync(uploaderPath)) {
        console.log('‚ö†Ô∏è  athlete-csv-uploader.js not found - skipping upload');
        console.log('   This should be your existing uploader that updates the lifters table');
        console.log('   Run manually later: node athlete-csv-uploader.js');
        return;
    }
    
    // Count files before upload
    const athletesDir = './output/athletes';
    let fileCountBefore = 0;
    if (fs.existsSync(athletesDir)) {
        fileCountBefore = fs.readdirSync(athletesDir).filter(f => f.endsWith('.csv')).length;
        console.log(`   Files to upload: ${fileCountBefore}`);
    }
    
    try {
        // Run YOUR existing uploader which handles the lifters table properly
        await new Promise((resolve, reject) => {
            const child = spawn('node', [uploaderPath], {
                stdio: 'inherit',
                env: { ...process.env }
            });
            
            child.on('close', (code) => {
                if (code === 0) {
                    console.log('‚úÖ Upload completed successfully');
                    resolve();
                } else {
                    // Non-zero exit code is OK - your uploader exits with 1 if there were some errors
                    console.log(`‚ö†Ô∏è  Upload completed with warnings (exit code: ${code})`);
                    resolve(); // Still resolve, don't reject
                }
            });
            
            child.on('error', (error) => {
                console.log(`‚ùå Failed to start uploader: ${error.message}`);
                reject(error);
            });
        });
        
        // Count remaining files after upload
        let fileCountAfter = 0;
        if (fs.existsSync(athletesDir)) {
            fileCountAfter = fs.readdirSync(athletesDir).filter(f => f.endsWith('.csv')).length;
            console.log(`   Files remaining: ${fileCountAfter}`);
            console.log(`   Files processed: ${fileCountBefore - fileCountAfter}`);
        }
        
    } catch (error) {
        console.log(`‚ö†Ô∏è  Upload process failed: ${error.message}`);
        console.log('   You can run manually later: node athlete-csv-uploader.js');
    }
}

// Main processing function
async function processBatchDivisions() {
    console.log('üöÄ Starting Batch Division Scraper');
    console.log(`üìÖ Day: ${CONFIG.DAY_NAME}`);
    console.log(`üéØ Division Range: ${CONFIG.DIVISION_START} to ${CONFIG.DIVISION_END}`);
    console.log(`üìÜ Date Range: Last month + Current month only`);
    console.log(`üïê Start time: ${new Date().toLocaleString('en-US', { timeZone: 'America/New_York' })}`);
    
    const allDivisions = loadDivisions();
    const batchDivisions = getDivisionsForBatch(allDivisions);
    
    if (batchDivisions.length === 0) {
        console.log('‚ùå No divisions to process in this range');
        return;
    }
    
    // Setup logging
    const logFile = `./completed_divisions_${CONFIG.DAY_NAME.toLowerCase()}.csv`;
    if (!fs.existsSync(logFile)) {
        const headers = ['division_number', 'division_name', 'timestamp', 'athletes_found', 
                        'athletes_processed', 'athletes_skipped', 'status', 'time_seconds'];
        fs.writeFileSync(logFile, headers.join(',') + '\n');
    }
    
    const issuesLogger = createExtractionIssuesLogger();
    
    // Launch browser
    const browser = await puppeteer.launch({
        headless: true,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-gpu'
        ],
        slowMo: 25
    });
    
    const page = await browser.newPage();
    await page.setViewport({ width: 1500, height: 1000 });
    
    let totalAthletesProcessed = 0;
    let totalDivisionsProcessed = 0;
    
    try {
        for (let i = 0; i < batchDivisions.length; i++) {
            const division = batchDivisions[i];
            const globalDivisionNumber = CONFIG.DIVISION_START + i;
            const startTime = Date.now();
            
            console.log(`\n${'='.repeat(60)}`);
            console.log(`Processing ${i + 1}/${batchDivisions.length} (Global #${globalDivisionNumber})`);
            
            const result = await scrapeDivisionAthletes(
                page, 
                division, 
                i, 
                globalDivisionNumber, 
                issuesLogger
            );
            
            let athletesProcessed = 0;
            let athletesSkipped = 0;
            
            if (result.success && result.athletes.length > 0) {
                // Process each athlete
                for (const athlete of result.athletes) {
                    if (!athlete.membershipId) continue;
                    
                    if (isAthleteAlreadyProcessed(athlete.membershipId)) {
                        athletesSkipped++;
                        continue;
                    }
                    
                    try {
                        const profileData = {
                            success: true,
                            profileData: {
                                athleteName: athlete.athleteName,
                                nationalRank: athlete.nationalRank,
                                membershipId: athlete.membershipId,
                                club: athlete.club,
                                wso: athlete.wso,
                                lifterAge: athlete.lifterAge,
                                liftDate: athlete.liftDate,
                                gender: athlete.gender,
                                total: athlete.total,
                                internalId: '',
                                competitionHistory: []
                            }
                        };
                        
                        createAthleteCSV(athlete.membershipId, profileData, division);
                        athletesProcessed++;
                        totalAthletesProcessed++;
                        
                    } catch (error) {
                        console.error(`   ‚ùå Error processing ${athlete.athleteName}: ${error.message}`);
                        issuesLogger.logIssue(
                            globalDivisionNumber,
                            division,
                            'ATHLETE_PROCESS_ERROR',
                            athlete.athleteName,
                            athlete.membershipId,
                            athlete,
                            error.message
                        );
                    }
                }
            }
            
            // Log division completion
            const timeSeconds = Math.round((Date.now() - startTime) / 1000);
            const logRow = [
                globalDivisionNumber,
                escapeCSV(division),
                new Date().toISOString(),
                result.totalFound,
                athletesProcessed,
                athletesSkipped,
                result.success ? 'SUCCESS' : 'FAILED',
                timeSeconds
            ];
            fs.appendFileSync(logFile, logRow.join(',') + '\n');
            
            console.log(`   ‚úÖ Division complete: ${athletesProcessed} processed, ${athletesSkipped} skipped`);
            console.log(`   ‚è±Ô∏è Time: ${timeSeconds} seconds`);
            totalDivisionsProcessed++;
            
            // Upload batch every 10 divisions or at the end
            if ((i + 1) % 10 === 0 || i === batchDivisions.length - 1) {
                await uploadBatchToSupabase();
            }
            
            // Delay between divisions
            if (i < batchDivisions.length - 1) {
                await new Promise(resolve => setTimeout(resolve, CONFIG.DELAY_BETWEEN_DIVISIONS));
            }
        }
        
    } catch (error) {
        console.error('üí• Fatal error:', error);
        throw error;
    } finally {
        await browser.close();
    }
    
    // Final upload
    await uploadBatchToSupabase();
    
    console.log('\n' + '='.repeat(60));
    console.log('üéâ Batch Processing Complete!');
    console.log(`üìä Summary for ${CONFIG.DAY_NAME}:`);
    console.log(`   Divisions processed: ${totalDivisionsProcessed}/${batchDivisions.length}`);
    console.log(`   Athletes processed: ${totalAthletesProcessed}`);
    console.log(`   Athletes CSV files created: ${totalAthletesProcessed}`);
    
    // Check how many files remain
    const athletesDir = './output/athletes';
    if (fs.existsSync(athletesDir)) {
        const remainingFiles = fs.readdirSync(athletesDir).filter(f => f.endsWith('.csv'));
        console.log(`   Files pending upload: ${remainingFiles.length}`);
    }
    
    console.log(`üïê End time: ${new Date().toLocaleString('en-US', { timeZone: 'America/New_York' })}`);
    
    return {
        divisionsProcessed: totalDivisionsProcessed,
        athletesProcessed: totalAthletesProcessed
    };
}

// Run the scraper
if (require.main === module) {
    processBatchDivisions()
        .then((results) => {
            console.log('‚úÖ Batch completed successfully');
            console.log(`üìà Final stats: ${results.divisionsProcessed} divisions, ${results.athletesProcessed} athletes`);
            process.exit(0);
        })
        .catch(error => {
            console.error('üí• Batch failed:', error);
            process.exit(1);
        });
}

module.exports = { processBatchDivisions };