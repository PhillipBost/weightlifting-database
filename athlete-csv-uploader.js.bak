const lifterUpdates = [];
        const competitionAgeUpdates = [];
        const newLifters = [];
        let duplicateCount = 0;
        let errorCount = 0;// Load environment variables from .env file
require('dotenv').config();

const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');
const Papa = require('papaparse');
const path = require('path');

// Initialize Supabase client with connection pooling and timeout settings
const supabase = createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_ANON_KEY,
    {
        db: {
            schema: 'public'
        },
        auth: {
            persistSession: false
        },
        global: {
            headers: {
                'Connection': 'keep-alive'
            }
        }
    }
);

// Add timeout wrapper for database operations
function withTimeout(promise, timeoutMs = 30000) {
    return Promise.race([
        promise,
        new Promise((_, reject) => 
            setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs)
        )
    ]);
}

async function readAthleteCSVFile(filePath) {
    console.log(`üìñ Reading athlete CSV file: ${path.basename(filePath)}`);
    
    if (!fs.existsSync(filePath)) {
        throw new Error(`CSV file not found: ${filePath}`);
    }
    
    const csvContent = fs.readFileSync(filePath, 'utf8');
    const parsed = Papa.parse(csvContent, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true
    });
    
    if (parsed.errors.length > 0) {
        console.log(`‚ö†Ô∏è CSV parsing warnings for ${path.basename(filePath)}:`, parsed.errors.slice(0, 3));
    }
    
    // Filter out rows without athlete_name (essential for matching)
    const validRows = parsed.data.filter(row => 
        row && row.athlete_name && row.athlete_name.toString().trim() !== ''
    );
    
    console.log(`üìä Parsed ${validRows.length} valid records from ${path.basename(filePath)}`);
    return validRows;
}

async function getAllAthleteCSVFiles() {
    const athletesDir = '../output/athletes';
    console.log(`üîç Scanning for athlete CSV files in: ${athletesDir}`);
    
    if (!fs.existsSync(athletesDir)) {
        throw new Error(`Athletes directory not found: ${athletesDir}`);
    }
    
    const files = fs.readdirSync(athletesDir)
        .filter(file => file.startsWith('athlete_') && file.endsWith('.csv'))
        .map(file => path.join(athletesDir, file));
    
    console.log(`üìÅ Found ${files.length} athlete CSV files`);
    return files;
}

function createErrorLogger() {
    const errorFilePath = './athlete_upload_errors.csv';
    const newLiftersFilePath = './new_lifters_created.csv';
    
    // Create error file with headers if it doesn't exist
    if (!fs.existsSync(errorFilePath)) {
        const headers = ['timestamp', 'athlete_name', 'membership_number', 'error_type', 'error_message'];
        fs.writeFileSync(errorFilePath, headers.join(',') + '\n');
    }
    
    // Create new lifters file with headers if it doesn't exist
    if (!fs.existsSync(newLiftersFilePath)) {
        const headers = ['timestamp', 'athlete_name', 'membership_number', 'gender', 'club_name', 'wso', 'birth_year', 'national_rank', 'division', 'note'];
        fs.writeFileSync(newLiftersFilePath, headers.join(',') + '\n');
    }
    
    return {
        logError: (athleteName, membershipNumber, errorType, errorMessage) => {
            const timestamp = new Date().toISOString();
            const row = [
                timestamp,
                `"${athleteName || ''}"`,
                membershipNumber || '',
                errorType,
                `"${errorMessage}"`
            ];
            fs.appendFileSync(errorFilePath, row.join(',') + '\n');
        },
        logNewLifter: (athleteData) => {
            const timestamp = new Date().toISOString();
            const row = [
                timestamp,
                `"${athleteData.athlete_name || ''}"`,
                athleteData.membership_number || '',
                `"${athleteData.gender || ''}"`,
                `"${athleteData.club_name || ''}"`,
                `"${athleteData.wso || ''}"`,
                athleteData.birth_year || '',
                athleteData.national_rank || '',
                `"${athleteData.division || ''}"`,
                '"Created from division scraper - no meet results found"'
            ];
            fs.appendFileSync(newLiftersFilePath, row.join(',') + '\n');
        }
    };
}

async function createNewLifter(athleteData) {
    const lifterData = {
        athlete_name: athleteData.athlete_name.toString().trim(),
        membership_number: athleteData.membership_number ? parseInt(athleteData.membership_number) : null,
        gender: athleteData.gender?.toString().trim() || null,
        club_name: athleteData.club_name?.toString().trim() || null,
        wso: athleteData.wso?.toString().trim() || null,
        birth_year: athleteData.birth_year ? parseInt(athleteData.birth_year) : null,
        national_rank: athleteData.national_rank ? parseInt(athleteData.national_rank) : null,
        internal_id: null, // Will be populated later by internal_id script
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
    };
    
    const { data: newLifter, error } = await withTimeout(
        supabase
            .from('lifters')
            .insert(lifterData)
            .select('lifter_id')
            .single(),
        15000 // 15 second timeout for individual inserts
    );
    
    if (error) {
        throw new Error(`Error creating new lifter: ${error.message}`);
    }
    
    console.log(`  ‚ûï Created new lifter: ${athleteData.athlete_name} (ID: ${newLifter.lifter_id})`);
    return newLifter.lifter_id;
}

// Optimized batch lifter creation
async function batchCreateNewLifters(newLifters, errorLogger) {
    if (newLifters.length === 0) return 0;
    
    console.log(`  ‚ûï Creating ${newLifters.length} new lifters in optimized batches...`);
    
    const batchSize = 10; // Smaller batches for reliability
    let createdCount = 0;
    
    for (let i = 0; i < newLifters.length; i += batchSize) {
        const batch = newLifters.slice(i, i + batchSize);
        const batchNumber = Math.floor(i / batchSize) + 1;
        const totalBatches = Math.ceil(newLifters.length / batchSize);
        
        console.log(`    üì¶ Creating batch ${batchNumber}/${totalBatches} (${batch.length} lifters)...`);
        
        // Prepare lifter data for batch insert
        const lifterDataBatch = batch.map(athleteData => ({
            athlete_name: athleteData.athlete_name.toString().trim(),
            membership_number: athleteData.membership_number ? parseInt(athleteData.membership_number) : null,
            gender: athleteData.gender?.toString().trim() || null,
            club_name: athleteData.club_name?.toString().trim() || null,
            wso: athleteData.wso?.toString().trim() || null,
            birth_year: athleteData.birth_year ? parseInt(athleteData.birth_year) : null,
            national_rank: athleteData.national_rank ? parseInt(athleteData.national_rank) : null,
            internal_id: null,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
        }));
        
        try {
            const { data: newLiftersResult, error } = await withTimeout(
                supabase
                    .from('lifters')
                    .insert(lifterDataBatch)
                    .select('lifter_id, athlete_name'),
                20000 // 20 second timeout for batch inserts
            );
            
            if (error) {
                console.log(`    ‚ùå Batch insert failed: ${error.message}`);
                // Fall back to individual inserts for this batch
                for (const athleteData of batch) {
                    try {
                        await createNewLifter(athleteData);
                        
                        const divisionString = `${athleteData['Age Category'] || ''} ${athleteData['Weight Class'] || ''}`.trim();
                        const enrichedAthleteData = { ...athleteData, division: divisionString };
                        errorLogger.logNewLifter(enrichedAthleteData);
                        createdCount++;
                    } catch (individualError) {
                        errorLogger.logError(athleteData.athlete_name, athleteData.membership_number, 'CREATE_ERROR', individualError.message);
                    }
                    
                    // Small delay between individual inserts
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            } else {
                // Batch insert successful
                console.log(`    ‚úÖ Successfully created ${newLiftersResult.length} lifters in batch`);
                
                // Log new lifters for review
                batch.forEach(athleteData => {
                    const divisionString = `${athleteData['Age Category'] || ''} ${athleteData['Weight Class'] || ''}`.trim();
                    const enrichedAthleteData = { ...athleteData, division: divisionString };
                    errorLogger.logNewLifter(enrichedAthleteData);
                });
                
                createdCount += newLiftersResult.length;
            }
        } catch (timeoutError) {
            console.log(`    ‚è∞ Batch insert timed out, falling back to individual inserts...`);
            // Fall back to individual inserts
            for (const athleteData of batch) {
                try {
                    await createNewLifter(athleteData);
                    
                    const divisionString = `${athleteData['Age Category'] || ''} ${athleteData['Weight Class'] || ''}`.trim();
                    const enrichedAthleteData = { ...athleteData, division: divisionString };
                    errorLogger.logNewLifter(enrichedAthleteData);
                    createdCount++;
                } catch (individualError) {
                    errorLogger.logError(athleteData.athlete_name, athleteData.membership_number, 'CREATE_ERROR', individualError.message);
                }
                
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        }
        
        // Delay between batches
        if (i + batchSize < newLifters.length) {
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }
    
    return createdCount;
}

async function findLifterByName(athleteName) {
    const { data: lifters, error } = await withTimeout(
        supabase
            .from('lifters')
            .select('lifter_id, athlete_name, membership_number, birth_year')
            .eq('athlete_name', athleteName),
        10000 // 10 second timeout for lookups
    );
    
    if (error) {
        throw new Error(`Error finding lifter: ${error.message}`);
    }
    
    return lifters;
}

async function updateLifter(lifterId, athleteData) {
    const updateData = {
        membership_number: athleteData.membership_number ? parseInt(athleteData.membership_number) : null,
        gender: athleteData.gender?.toString().trim() || null,
        club_name: athleteData.club_name?.toString().trim() || null,
        wso: athleteData.wso?.toString().trim() || null,
        birth_year: athleteData.birth_year ? parseInt(athleteData.birth_year) : null,
        national_rank: athleteData.national_rank ? parseInt(athleteData.national_rank) : null,
        updated_at: new Date().toISOString()
    };
    
    const { error } = await withTimeout(
        supabase
            .from('lifters')
            .update(updateData)
            .eq('lifter_id', lifterId),
        10000 // 10 second timeout for updates
    );
    
    if (error) {
        throw new Error(`Error updating lifter: ${error.message}`);
    }
    
    return updateData;
}

async function batchUpdateLifters(lifterUpdates) {
    if (lifterUpdates.length === 0) return;
    
    console.log(`  üîÑ Batch updating ${lifterUpdates.length} lifters...`);
    
    const batchSize = 25; // Smaller batches for better reliability
    for (let i = 0; i < lifterUpdates.length; i += batchSize) {
        const batch = lifterUpdates.slice(i, i + batchSize);
        const batchNumber = Math.floor(i / batchSize) + 1;
        const totalBatches = Math.ceil(lifterUpdates.length / batchSize);
        
        console.log(`    üì¶ Processing update batch ${batchNumber}/${totalBatches} (${batch.length} lifters)...`);
        
        try {
            // Update each lifter in the batch with timeout
            const updatePromises = batch.map(update => 
                withTimeout(
                    supabase
                        .from('lifters')
                        .update({
                            membership_number: update.membership_number,
                            gender: update.gender,
                            club_name: update.club_name,
                            wso: update.wso,
                            birth_year: update.birth_year,
                            national_rank: update.national_rank,
                            updated_at: new Date().toISOString()
                        })
                        .eq('lifter_id', update.lifter_id),
                    8000 // 8 second timeout per update
                )
            );
            
            await Promise.all(updatePromises);
            console.log(`    ‚úÖ Completed batch ${batchNumber}/${totalBatches}`);
            
        } catch (batchError) {
            console.log(`    ‚ö†Ô∏è Batch ${batchNumber} had errors: ${batchError.message}`);
            // Try individual updates for this batch
            for (const update of batch) {
                try {
                    await updateLifter(update.lifter_id, update);
                } catch (individualError) {
                    console.log(`    ‚ùå Failed to update lifter ${update.lifter_id}: ${individualError.message}`);
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
        
        // Delay between batches
        if (i + batchSize < lifterUpdates.length) {
            await new Promise(resolve => setTimeout(resolve, 300));
        }
    }
    
    console.log(`    ‚úÖ Completed updating ${lifterUpdates.length} lifters`);
}

// Simplified competition age updates - skip for now to avoid hanging
async function batchUpdateCompetitionAges(competitionAgeUpdates) {
    if (competitionAgeUpdates.length === 0) return;
    
    console.log(`  üîÑ Skipping competition age updates for ${competitionAgeUpdates.length} lifters (performance optimization)`);
    console.log(`  üí° Competition ages can be calculated later with a separate script if needed`);
    
    // We're skipping this to prevent hanging - this can be done in a separate optimization pass
    return;
}

async function processAthleteCSVFile(filePath, errorLogger) {
    const fileName = path.basename(filePath);
    console.log(`\nüìÑ Processing: ${fileName}`);
    
    try {
        const athleteRecords = await readAthleteCSVFile(filePath);
        
        if (athleteRecords.length === 0) {
            console.log(`  ‚ö†Ô∏è No valid records found in ${fileName}`);
            return { updated: 0, created: 0, notFound: 0, duplicates: 0, errors: 0, success: true };
        }
        
        // Process all records in the file
        const recordsToProcess = athleteRecords;
        
        console.log(`  üîç Looking up ${recordsToProcess.length} athletes...`);
        
        // Process in smaller chunks to avoid overwhelming the database
        const chunkSize = 10;
        for (let i = 0; i < recordsToProcess.length; i += chunkSize) {
            const chunk = recordsToProcess.slice(i, i + chunkSize);
            
            for (const athleteData of chunk) {
                try {
                    const athleteName = athleteData.athlete_name.toString().trim();
                    const matchingLifters = await findLifterByName(athleteName);
                    
                    if (matchingLifters.length === 0) {
                        newLifters.push(athleteData);
                        continue;
                    }
                    
                    if (matchingLifters.length > 1) {
                        errorLogger.logError(athleteName, athleteData.membership_number, 'DUPLICATE_NAMES', `Found ${matchingLifters.length} lifters with same name`);
                        duplicateCount++;
                        continue;
                    }
                    
                    const lifter = matchingLifters[0];
                    
                    // Prepare lifter update
                    const updateData = {
                        lifter_id: lifter.lifter_id,
                        membership_number: athleteData.membership_number ? parseInt(athleteData.membership_number) : null,
                        gender: athleteData.gender?.toString().trim() || null,
                        club_name: athleteData.club_name?.toString().trim() || null,
                        wso: athleteData.wso?.toString().trim() || null,
                        birth_year: athleteData.birth_year ? parseInt(athleteData.birth_year) : null,
                        national_rank: athleteData.national_rank ? parseInt(athleteData.national_rank) : null,
                        athlete_name: athleteName
                    };
                    
                    lifterUpdates.push(updateData);
                    
                    // Skip competition age updates for now
                    
                } catch (error) {
                    errorLogger.logError(athleteData.athlete_name, athleteData.membership_number, 'LOOKUP_ERROR', error.message);
                    errorCount++;
                }
            }
            
            // Small delay between chunks
            if (i + chunkSize < recordsToProcess.length) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
        
        // Batch update existing lifters
        if (lifterUpdates.length > 0) {
            await batchUpdateLifters(lifterUpdates);
        }
        
        // Batch create new lifters
        const newLiftersCreated = await batchCreateNewLifters(newLifters, errorLogger);
        
        // Skip competition age updates for performance
        
        console.log(`  üìä Results: ${lifterUpdates.length} updated, ${newLiftersCreated} created, ${duplicateCount} duplicates, ${errorCount} errors`);
        
        return { 
            updated: lifterUpdates.length, 
            created: newLiftersCreated,
            notFound: 0, 
            duplicates: duplicateCount, 
            errors: errorCount,
            success: errorCount === 0
        };
        
    } catch (error) {
        console.error(`üí• Error processing file ${fileName}:`, error.message);
        return { updated: 0, created: 0, notFound: 0, duplicates: 0, errors: 1, success: false };
    }
}

async function getExistingCounts() {
    console.log('üìä Checking existing record counts in database...');
    
    try {
        const liftersResult = await withTimeout(
            supabase.from('lifters').select('*', { count: 'exact', head: true }),
            10000
        );
        
        if (liftersResult.error) {
            console.error('‚ö†Ô∏è Could not get lifter count:', liftersResult.error);
            return { lifters: null, results: null };
        }
        
        console.log(`üìà Database currently has ${liftersResult.count} lifters`);
        return { lifters: liftersResult.count, results: null };
        
    } catch (error) {
        console.error('‚ö†Ô∏è Error getting existing counts:', error.message);
        return { lifters: null, results: null };
    }
}

async function main() {
    console.log('üèãÔ∏è Athlete CSV to Supabase Upload Started (Optimized)');
    console.log('====================================================');
    console.log(`üïê Start time: ${new Date().toLocaleString('en-US', { timeZone: 'America/New_York' })}`);
    
    try {
        // Check Supabase connection with timeout
        console.log('üîó Testing Supabase connection...');
        
        if (!process.env.SUPABASE_URL || !process.env.SUPABASE_ANON_KEY) {
            throw new Error('Missing Supabase environment variables (SUPABASE_URL, SUPABASE_ANON_KEY)');
        }
        
        // Test connection with timeout
        const { data: testData, error: testError } = await withTimeout(
            supabase
                .from('lifters')
                .select('lifter_id')
                .limit(1),
            10000
        );
        
        if (testError) {
            throw new Error(`Supabase connection failed: ${testError.message}`);
        }
        console.log('‚úÖ Supabase connection successful');
        
        // Get existing counts before import
        const beforeCounts = await getExistingCounts();
        
        // Create error logger
        const errorLogger = createErrorLogger();
        
        // Get all athlete CSV files
        const csvFiles = await getAllAthleteCSVFiles();
        
        if (csvFiles.length === 0) {
            console.log('‚ö†Ô∏è No athlete CSV files found');
            return;
        }
        
        // Process ALL files (no artificial limit)
        const filesToProcess = csvFiles;
        
        console.log(`\nüì• Processing ${filesToProcess.length} athlete CSV files...`);
        
        let totalUpdated = 0;
        let totalCreated = 0;
        let totalDuplicates = 0;
        let totalErrors = 0;
        let filesProcessed = 0;
        
        // Process files one at a time to avoid overwhelming the database
        for (const filePath of filesToProcess) {
            const fileName = path.basename(filePath);
            console.log(`\nüîÑ Starting file: ${fileName} (${filesProcessed + 1}/${filesToProcess.length})`);
            
            try {
                const result = await processAthleteCSVFile(filePath, errorLogger);
                totalUpdated += result.updated;
                totalCreated += result.created || 0;
                totalDuplicates += result.duplicates;
                totalErrors += result.errors;
                filesProcessed++;
                
                console.log(`‚úÖ Completed file: ${fileName}`);
                
                // Delete CSV file if processing was successful
                if (result.success) {
                    try {
                        fs.unlinkSync(filePath);
                        console.log(`üóëÔ∏è Deleted: ${fileName}`);
                    } catch (deleteError) {
                        console.log(`‚ö†Ô∏è Could not delete ${fileName}: ${deleteError.message}`);
                    }
                } else {
                    console.log(`üìÑ Kept: ${fileName} (had errors)`);
                }
                
            } catch (fileError) {
                console.log(`üí• Error processing file ${fileName}:`, fileError.message);
                totalErrors++;
                filesProcessed++;
            }
            
            // Small delay between files
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // Report results
        console.log('\nüìä Athlete Update Summary:');
        console.log(`üìÅ CSV files processed: ${filesProcessed}`);
        console.log(`‚úÖ Lifters updated: ${totalUpdated}`);
        console.log(`‚ûï New lifters created: ${totalCreated}`);
        console.log(`üë• Duplicate names: ${totalDuplicates}`);
        console.log(`‚ùå Errors: ${totalErrors}`);
        console.log(`üìÑ Error log: ./athlete_upload_errors.csv`);
        if (totalCreated > 0) {
            console.log(`üÜï New lifters log: ./new_lifters_created.csv`);
        }
        
        if (totalErrors + totalDuplicates > 0) {
            console.log('‚ö†Ô∏è Some records had issues. Check error logs for details.');
        } else {
            console.log('‚úÖ All records processed successfully!');
        }
        
        console.log(`üïê End time: ${new Date().toLocaleString()}`);
        
    } catch (error) {
        console.error('üí• Athlete CSV upload failed:', error.message);
        console.error('Stack trace:', error.stack);
        process.exit(1);
    }
}

// Run if called directly
if (require.main === module) {
    main();
}

module.exports = {
    main,
    processAthleteCSVFile
};