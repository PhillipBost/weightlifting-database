// Load environment variables from .env file
require('dotenv').config();

const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');
const Papa = require('papaparse');
const path = require('path');

// Initialize Supabase client - SIMPLE VERSION
const supabase = createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_ANON_KEY
);

// MINIMAL timeout wrapper - only for the most critical operations
function withTimeout(promise, timeoutMs = 30000) {
    return Promise.race([
        promise,
        new Promise((_, reject) => 
            setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs)
        )
    ]);
}

async function readAthleteCSVFile(filePath) {
    console.log(`üìñ Reading athlete CSV file: ${path.basename(filePath)}`);
    
    if (!fs.existsSync(filePath)) {
        throw new Error(`CSV file not found: ${filePath}`);
    }
    
    const csvContent = fs.readFileSync(filePath, 'utf8');
    const parsed = Papa.parse(csvContent, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true
    });
    
    if (parsed.errors.length > 0) {
        console.log(`‚ö†Ô∏è CSV parsing warnings for ${path.basename(filePath)}:`, parsed.errors.slice(0, 3));
    }
    
    // Filter out rows without athlete_name (essential for matching)
    const validRows = parsed.data.filter(row => 
        row && row.athlete_name && row.athlete_name.toString().trim() !== ''
    );
    
    console.log(`üìä Parsed ${validRows.length} valid records from ${path.basename(filePath)}`);
    return validRows;
}

async function getAllAthleteCSVFiles() {
    const athletesDir = 'output/athletes';
    console.log(`üîç Scanning for athlete CSV files in: ${athletesDir}`);
    
    if (!fs.existsSync(athletesDir)) {
        throw new Error(`Athletes directory not found: ${athletesDir}`);
    }
    
    const files = fs.readdirSync(athletesDir)
        .filter(file => file.startsWith('athlete_') && file.endsWith('.csv'))
        .map(file => path.join(athletesDir, file));
    
    console.log(`üìÅ Found ${files.length} athlete CSV files`);
    return files;
}

function createErrorLogger() {
    const errorFilePath = './athlete_upload_errors.csv';
    const newLiftersFilePath = './new_lifters_created.csv';
    
    // Create error file with headers if it doesn't exist
    if (!fs.existsSync(errorFilePath)) {
        const headers = ['timestamp', 'athlete_name', 'membership_number', 'error_type', 'error_message'];
        fs.writeFileSync(errorFilePath, headers.join(',') + '\n');
    }
    
    // Create new lifters file with headers if it doesn't exist
    if (!fs.existsSync(newLiftersFilePath)) {
        const headers = ['timestamp', 'athlete_name', 'membership_number', 'gender', 'club_name', 'wso', 'birth_year', 'national_rank', 'division', 'note'];
        fs.writeFileSync(newLiftersFilePath, headers.join(',') + '\n');
    }
    
    return {
        logError: (athleteName, membershipNumber, errorType, errorMessage) => {
            const timestamp = new Date().toISOString();
            const row = [
                timestamp,
                `"${athleteName || ''}"`,
                membershipNumber || '',
                errorType,
                `"${errorMessage}"`
            ];
            fs.appendFileSync(errorFilePath, row.join(',') + '\n');
        },
        logNewLifter: (athleteData) => {
            const timestamp = new Date().toISOString();
            const row = [
                timestamp,
                `"${athleteData.athlete_name || ''}"`,
                athleteData.membership_number || '',
                `"${athleteData.gender || ''}"`,
                `"${athleteData.club_name || ''}"`,
                `"${athleteData.wso || ''}"`,
                athleteData.birth_year || '',
                athleteData.national_rank || '',
                `"${athleteData.division || ''}"`,
                '"Created from division scraper - no meet results found"'
            ];
            fs.appendFileSync(newLiftersFilePath, row.join(',') + '\n');
        }
    };
}

async function createNewLifter(athleteData) {
    const lifterData = {
        athlete_name: athleteData.athlete_name.toString().trim(),
        membership_number: athleteData.membership_number ? parseInt(athleteData.membership_number) : null,
        gender: athleteData.gender?.toString().trim() || null,
        club_name: athleteData.club_name?.toString().trim() || null,
        wso: athleteData.wso?.toString().trim() || null,
        birth_year: athleteData.birth_year ? parseInt(athleteData.birth_year) : null,
        national_rank: athleteData.national_rank ? parseInt(athleteData.national_rank) : null,
        internal_id: null, // Will be populated later by internal_id script
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
    };
    
    const { data: newLifter, error } = await supabase
        .from('lifters')
        .insert(lifterData)
        .select('lifter_id')
        .single();
    
    if (error) {
        throw new Error(`Error creating new lifter: ${error.message}`);
    }
    
    console.log(`  ‚ûï Created new lifter: ${athleteData.athlete_name} (ID: ${newLifter.lifter_id})`);
    return newLifter.lifter_id;
}

// Fixed: Added missing async keyword to findLifterByName function
async function findLifterByName(athleteName) {
    const { data: lifters, error } = await supabase
        .from('lifters')
        .select('lifter_id, athlete_name, membership_number, birth_year')
        .eq('athlete_name', athleteName);
    
    if (error) {
        throw new Error(`Error finding lifter: ${error.message}`);
    }
    
    return lifters;
}

async function updateLifter(lifterId, athleteData) {
    const updateData = {
        membership_number: athleteData.membership_number ? parseInt(athleteData.membership_number) : null,
        gender: athleteData.gender?.toString().trim() || null,
        club_name: athleteData.club_name?.toString().trim() || null,
        wso: athleteData.wso?.toString().trim() || null,
        birth_year: athleteData.birth_year ? parseInt(athleteData.birth_year) : null,
        national_rank: athleteData.national_rank ? parseInt(athleteData.national_rank) : null,
        updated_at: new Date().toISOString()
    };
    
    const { error } = await supabase
        .from('lifters')
        .update(updateData)
        .eq('lifter_id', lifterId);
    
    if (error) {
        throw new Error(`Error updating lifter: ${error.message}`);
    }
    
    return updateData;
}

async function batchUpdateLifters(lifterUpdates) {
    if (lifterUpdates.length === 0) return;
    
    console.log(`  üîÑ Batch updating ${lifterUpdates.length} lifters...`);
    
    // Use YOUR original batch size
    const batchSize = 50;
    for (let i = 0; i < lifterUpdates.length; i += batchSize) {
        const batch = lifterUpdates.slice(i, i + batchSize);
        const batchNumber = Math.floor(i / batchSize) + 1;
        const totalBatches = Math.ceil(lifterUpdates.length / batchSize);
        
        console.log(`    üì¶ Processing update batch ${batchNumber}/${totalBatches} (${batch.length} lifters)...`);
        
        // Update each lifter in the batch
        const updatePromises = batch.map(update => 
            supabase
                .from('lifters')
                .update({
                    membership_number: update.membership_number,
                    gender: update.gender,
                    club_name: update.club_name,
                    wso: update.wso,
                    birth_year: update.birth_year,
                    national_rank: update.national_rank,
                    updated_at: new Date().toISOString()
                })
                .eq('lifter_id', update.lifter_id)
        );
        
        await Promise.all(updatePromises);
        
        // Small delay between batches
        if (i + batchSize < lifterUpdates.length) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }
    
    console.log(`    ‚úÖ Completed updating ${lifterUpdates.length} lifters`);
}

// SKIP competition age updates entirely for now
async function batchUpdateCompetitionAges(competitionAgeUpdates) {
    console.log(`  ‚è≠Ô∏è Skipping competition age updates for ${competitionAgeUpdates.length} lifters`);
    return;
}

async function updateRecentMeetResultsWithCurrentAffiliation(lifterId, athleteData, errorLogger) {
    // For nightly runs, we're seeing the athlete's CURRENT affiliation
    // Update their recent meet results (last 2-3 months) with this info
    
    if (!athleteData.wso || !athleteData.club_name) {
        return { updated: 0, errors: 0 };
    }
    
    try {
        // Calculate date range for recent meets
        const today = new Date();
        const threeMonthsAgo = new Date(today);
        threeMonthsAgo.setMonth(today.getMonth() - 3);
        const dateString = threeMonthsAgo.toISOString().split('T')[0];
        
        console.log(`  üîÑ Updating recent meet_results for lifter ${lifterId} since ${dateString}`);
        
        // Find recent meet results that don't have WSO/club set
        const { data: meetResults, error: findError } = await supabase
            .from('meet_results')
            .select('result_id, date, meet_name, wso, club_name')
            .eq('lifter_id', lifterId)
            .gte('date', dateString)
            .or('wso.is.null,club_name.is.null,wso.eq.,club_name.eq.');
        
        if (findError) {
            throw new Error(`Error finding meet results: ${findError.message}`);
        }
        
        if (!meetResults || meetResults.length === 0) {
            return { updated: 0, errors: 0 };
        }
        
        console.log(`  üìä Found ${meetResults.length} recent meet_results to update`);
        
        // Update with current affiliation
        const { error: updateError } = await supabase
            .from('meet_results')
            .update({
                wso: athleteData.wso.toString().trim(),
                club_name: athleteData.club_name.toString().trim(),
                updated_at: new Date().toISOString()
            })
            .in('result_id', meetResults.map(r => r.result_id));
        
        if (updateError) {
            throw new Error(`Error updating meet results: ${updateError.message}`);
        }
        
        console.log(`  ‚úÖ Updated ${meetResults.length} recent meet_results with current WSO/club`);
        
        return { updated: meetResults.length, errors: 0 };
        
    } catch (error) {
        console.error(`  üí• Error updating meet_results:`, error.message);
        errorLogger.logError(
            athleteData.athlete_name,
            athleteData.membership_number,
            'MEET_RESULTS_UPDATE_ERROR',
            error.message
        );
        return { updated: 0, errors: 1 };
    }
}

async function processAthleteCSVFile(filePath, errorLogger) {
    const fileName = path.basename(filePath);
    console.log(`\nüìÑ Processing: ${fileName}`);
    
    try {
        const athleteRecords = await readAthleteCSVFile(filePath);
        
        if (athleteRecords.length === 0) {
            console.log(`  ‚ö†Ô∏è No valid records found in ${fileName}`);
            return { updated: 0, created: 0, notFound: 0, duplicates: 0, errors: 0, success: true };
        }
        
        // First, find all lifters and check for issues
        const lifterUpdates = [];
        const competitionAgeUpdates = [];
        const newLifters = [];
        let notFoundCount = 0;
        let duplicateCount = 0;
        let errorCount = 0;
        
        console.log(`  üîç Looking up ${athleteRecords.length} athletes...`);
        
        let processedCount = 0;
        for (const athleteData of athleteRecords) {
            processedCount++;
            
            if (processedCount % 25 === 0) {
                console.log(`  üìä Progress: ${processedCount}/${athleteRecords.length} athletes processed`);
            }
            
            try {
                const athleteName = athleteData.athlete_name.toString().trim();
                const matchingLifters = await findLifterByName(athleteName);
                
                if (matchingLifters.length === 0) {
                    // Create new lifter
                    console.log(`  ‚ûï Will create new lifter: ${athleteName}`);
                    newLifters.push(athleteData);
                    continue;
                }
                
                if (matchingLifters.length > 1) {
                    errorLogger.logError(athleteName, athleteData.membership_number, 'DUPLICATE_NAMES', `Found ${matchingLifters.length} lifters with same name`);
                    duplicateCount++;
                    continue;
                }
                
                const lifter = matchingLifters[0];
                
                // Prepare lifter update
                const updateData = {
                    lifter_id: lifter.lifter_id,
                    membership_number: athleteData.membership_number ? parseInt(athleteData.membership_number) : null,
                    gender: athleteData.gender?.toString().trim() || null,
                    club_name: athleteData.club_name?.toString().trim() || null,
                    wso: athleteData.wso?.toString().trim() || null,
                    birth_year: athleteData.birth_year ? parseInt(athleteData.birth_year) : null,
                    national_rank: athleteData.national_rank ? parseInt(athleteData.national_rank) : null,
                    athlete_name: athleteName
                };
                
                lifterUpdates.push(updateData);
                
                // Skip competition age updates for now
                
            } catch (error) {
                errorLogger.logError(athleteData.athlete_name, athleteData.membership_number, 'LOOKUP_ERROR', error.message);
                errorCount++;
            }
        }
        
        // Batch update existing lifters
        if (lifterUpdates.length > 0) {
            await batchUpdateLifters(lifterUpdates);
        }
        
        // Create new lifters one by one (like your original)
        let newLiftersCreated = 0;
        if (newLifters.length > 0) {
            console.log(`  ‚ûï Creating ${newLifters.length} new lifters...`);
            for (let i = 0; i < newLifters.length; i++) {
                const athleteData = newLifters[i];
                
                if (i > 0 && i % 10 === 0) {
                    console.log(`    üìà Created ${i}/${newLifters.length} new lifters so far...`);
                }
                
                try {
                    await createNewLifter(athleteData);
                    
                    // Create division string from Age Category and Weight Class for logging
                    const divisionString = `${athleteData['Age Category'] || ''} ${athleteData['Weight Class'] || ''}`.trim();
                    const enrichedAthleteData = {
                        ...athleteData,
                        division: divisionString
                    };
                    errorLogger.logNewLifter(enrichedAthleteData);
                    newLiftersCreated++;
                } catch (error) {
                    errorLogger.logError(athleteData.athlete_name, athleteData.membership_number, 'CREATE_ERROR', error.message);
                    errorCount++;
                }
                
                // Add brief pause after every 5 new lifters created
                if (newLiftersCreated > 0 && newLiftersCreated % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }
        }
        
		if (matchingLifters.length === 1) {
			const lifter = matchingLifters[0];
			const lifterId = lifter.lifter_id;
			
			// Check if WSO or club changed
			const wsoChanged = lifter.wso !== athleteData.wso;
			const clubChanged = lifter.club_name !== athleteData.club_name;
			
			if (wsoChanged || clubChanged) {
				console.log(`  üîÑ Affiliation change detected for ${athleteName}:`);
				if (wsoChanged) console.log(`    WSO: "${lifter.wso}" ‚Üí "${athleteData.wso}"`);
				if (clubChanged) console.log(`    Club: "${lifter.club_name}" ‚Üí "${athleteData.club_name}"`);
				
				// Track the change (optional - create a history table)
				await trackAffiliationChange(lifterId, {
					old_wso: lifter.wso,
					new_wso: athleteData.wso,
					old_club: lifter.club_name,
					new_club: athleteData.club_name,
					change_detected: new Date().toISOString()
				});
			}
			
			// Update lifter table (current state)
			lifterUpdates.push(updateData);
			
			// Update recent meet_results with current affiliation
			const meetResultsUpdate = await updateRecentMeetResultsWithCurrentAffiliation(
				lifterId, 
				athleteData, 
				errorLogger
			);
			meetResultsUpdated += meetResultsUpdate.updated;
		}
		
        // SKIP competition age updates
        
        console.log(`  üìä Results: ${lifterUpdates.length} updated, ${newLiftersCreated} created, ${duplicateCount} duplicates, ${errorCount} errors`);
        
        return { 
            updated: lifterUpdates.length, 
            created: newLiftersCreated,
            notFound: notFoundCount, 
            duplicates: duplicateCount, 
            errors: errorCount,
            success: errorCount === 0
        };
        
    } catch (error) {
        console.error(`üí• Error processing file ${fileName}:`, error.message);
        return { updated: 0, created: 0, notFound: 0, duplicates: 0, errors: 1, success: false };
    }
}

async function main() {
    console.log('üèãÔ∏è Athlete CSV to Supabase Upload Started (Minimal Fix)');
    console.log('========================================================');
    console.log(`üïê Start time: ${new Date().toLocaleString('en-US', { timeZone: 'America/New_York' })}`);
    
    try {
        // Check Supabase connection
        console.log('üîó Testing Supabase connection...');
        
        if (!process.env.SUPABASE_URL || !process.env.SUPABASE_ANON_KEY) {
            throw new Error('Missing Supabase environment variables (SUPABASE_URL, SUPABASE_ANON_KEY)');
        }
        
        // Test connection - ONLY add timeout here where it's most likely to hang
        const { data: testData, error: testError } = await withTimeout(
            supabase
                .from('lifters')
                .select('lifter_id')
                .limit(1),
            10000
        );
        
        if (testError) {
            throw new Error(`Supabase connection failed: ${testError.message}`);
        }
        console.log('‚úÖ Supabase connection successful');
        
        // Create error logger
        const errorLogger = createErrorLogger();
        
        // Get all athlete CSV files
        const csvFiles = await getAllAthleteCSVFiles();
        
        if (csvFiles.length === 0) {
            console.log('‚ö†Ô∏è No athlete CSV files found');
            return;
        }
        
        console.log(`\nüì• Processing ${csvFiles.length} athlete CSV files...`);
        
        let totalUpdated = 0;
        let totalCreated = 0;
        let totalNotFound = 0;
        let totalDuplicates = 0;
        let totalErrors = 0;
        let filesProcessed = 0;
        
        // Process files one at a time
        for (const filePath of csvFiles) {
            const fileName = path.basename(filePath);
            console.log(`\nüîÑ Starting file: ${fileName} (${filesProcessed + 1}/${csvFiles.length})`);
            
            try {
                const result = await processAthleteCSVFile(filePath, errorLogger);
                totalUpdated += result.updated;
                totalCreated += result.created || 0;
                totalNotFound += result.notFound;
                totalDuplicates += result.duplicates;
                totalErrors += result.errors;
                filesProcessed++;
                
                console.log(`‚úÖ Completed file: ${fileName}`);
                
                // Delete CSV file if processing was successful (no errors)
                if (result.success) {
                    try {
                        fs.unlinkSync(filePath);
                        console.log(`üóëÔ∏è Deleted: ${fileName}`);
                    } catch (deleteError) {
                        console.log(`‚ö†Ô∏è Could not delete ${fileName}: ${deleteError.message}`);
                    }
                } else {
                    console.log(`üìÑ Kept: ${fileName} (had errors)`);
                }
                
            } catch (fileError) {
                console.log(`üí• Error processing file ${fileName}:`, fileError.message);
                totalErrors++;
                filesProcessed++;
            }
            
            // Progress indicator
            if (filesProcessed % 25 === 0) {
                console.log(`\nüîÑ Progress: ${filesProcessed}/${csvFiles.length} files processed`);
            }
        }
        
        // Report results
        console.log('\nüìä Athlete Update Summary:');
        console.log(`üìÅ CSV files processed: ${filesProcessed}`);
        console.log(`‚úÖ Lifters updated: ${totalUpdated}`);
        console.log(`‚ûï New lifters created: ${totalCreated}`);
        console.log(`‚ùì Not found: ${totalNotFound}`);
        console.log(`üë• Duplicate names: ${totalDuplicates}`);
        console.log(`‚ùå Errors: ${totalErrors}`);
        console.log(`üìÑ Error log: ./athlete_upload_errors.csv`);
        if (totalCreated > 0) {
            console.log(`üÜï New lifters log: ./new_lifters_created.csv`);
        }
        
        if (totalErrors + totalNotFound + totalDuplicates > 0) {
            console.log('‚ö†Ô∏è Some records had issues. Check error logs for details.');
        } else {
            console.log('‚úÖ All records processed successfully!');
        }
        
        console.log(`üïê End time: ${new Date().toLocaleString()}`);
        
    } catch (error) {
        console.error('üí• Athlete CSV upload failed:', error.message);
        process.exit(1);
    }
}

// Run if called directly
if (require.main === module) {
    main();
}

module.exports = {
    main
};